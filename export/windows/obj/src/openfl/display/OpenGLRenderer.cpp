// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime__internal_backend_native_NativeOpenGLRenderContext
#include <lime/_internal/backend/native/NativeOpenGLRenderContext.h>
#endif
#ifndef INCLUDED_lime_app_IModule
#include <lime/app/IModule.h>
#endif
#ifndef INCLUDED_lime_graphics_RenderContext
#include <lime/graphics/RenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics_cairo_Cairo
#include <lime/graphics/cairo/Cairo.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_math__Matrix4_Matrix4_Impl_
#include <lime/math/_Matrix4/Matrix4_Impl_.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_lime_utils_ObjectPool_openfl_geom_Matrix
#include <lime/utils/ObjectPool_openfl_geom_Matrix.h>
#endif
#ifndef INCLUDED_lime_utils__DataPointer_DataPointer_Impl_
#include <lime/utils/_DataPointer/DataPointer_Impl_.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_ObjectVector
#include <openfl/_Vector/ObjectVector.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_ShaderBuffer
#include <openfl/_internal/renderer/ShaderBuffer.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_GLMaskShader
#include <openfl/_internal/renderer/opengl/GLMaskShader.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_CairoRenderer
#include <openfl/display/CairoRenderer.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectRenderer
#include <openfl/display/DisplayObjectRenderer.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectShader
#include <openfl/display/DisplayObjectShader.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_OpenGLRenderer
#include <openfl/display/OpenGLRenderer.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderInput_openfl_display_BitmapData
#include <openfl/display/ShaderInput_openfl_display_BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Bool
#include <openfl/display/ShaderParameter_Bool.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Float
#include <openfl/display/ShaderParameter_Float.h>
#endif
#ifndef INCLUDED_openfl_display_Stage
#include <openfl/display/Stage.h>
#endif
#ifndef INCLUDED_openfl_display_Stage3D
#include <openfl/display/Stage3D.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_utils_ByteArrayData
#include <openfl/utils/ByteArrayData.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataInput
#include <openfl/utils/IDataInput.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataOutput
#include <openfl/utils/IDataOutput.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_2f59d7e567bca573_106_new,"openfl.display.OpenGLRenderer","new",0x318619ae,"openfl.display.OpenGLRenderer.new","openfl/display/OpenGLRenderer.hx",106,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_172_applyAlpha,"openfl.display.OpenGLRenderer","applyAlpha",0xd5dfbf82,"openfl.display.OpenGLRenderer.applyAlpha","openfl/display/OpenGLRenderer.hx",172,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_191_applyBitmapData,"openfl.display.OpenGLRenderer","applyBitmapData",0x4c599b15,"openfl.display.OpenGLRenderer.applyBitmapData","openfl/display/OpenGLRenderer.hx",191,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_244_applyColorTransform,"openfl.display.OpenGLRenderer","applyColorTransform",0xad8c9ae5,"openfl.display.OpenGLRenderer.applyColorTransform","openfl/display/OpenGLRenderer.hx",244,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_284_applyHasColorTransform,"openfl.display.OpenGLRenderer","applyHasColorTransform",0x4989d2a7,"openfl.display.OpenGLRenderer.applyHasColorTransform","openfl/display/OpenGLRenderer.hx",284,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_303_applyMatrix,"openfl.display.OpenGLRenderer","applyMatrix",0xc7743d9d,"openfl.display.OpenGLRenderer.applyMatrix","openfl/display/OpenGLRenderer.hx",303,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_318_getMatrix,"openfl.display.OpenGLRenderer","getMatrix",0xa537f745,"openfl.display.OpenGLRenderer.getMatrix","openfl/display/OpenGLRenderer.hx",318,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_347_setShader,"openfl.display.OpenGLRenderer","setShader",0xe9e16c35,"openfl.display.OpenGLRenderer.setShader","openfl/display/OpenGLRenderer.hx",347,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_379_setViewport,"openfl.display.OpenGLRenderer","setViewport",0x9cb75d76,"openfl.display.OpenGLRenderer.setViewport","openfl/display/OpenGLRenderer.hx",379,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_386_updateShader,"openfl.display.OpenGLRenderer","updateShader",0x08518300,"openfl.display.OpenGLRenderer.updateShader","openfl/display/OpenGLRenderer.hx",386,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_399_useAlphaArray,"openfl.display.OpenGLRenderer","useAlphaArray",0x92a9e750,"openfl.display.OpenGLRenderer.useAlphaArray","openfl/display/OpenGLRenderer.hx",399,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_410_useColorTransformArray,"openfl.display.OpenGLRenderer","useColorTransformArray",0xf01908bb,"openfl.display.OpenGLRenderer.useColorTransformArray","openfl/display/OpenGLRenderer.hx",410,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_420___cleanup,"openfl.display.OpenGLRenderer","__cleanup",0x99a994d2,"openfl.display.OpenGLRenderer.__cleanup","openfl/display/OpenGLRenderer.hx",420,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_439___clear,"openfl.display.OpenGLRenderer","__clear",0x8e85d2bb,"openfl.display.OpenGLRenderer.__clear","openfl/display/OpenGLRenderer.hx",439,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_458___clearShader,"openfl.display.OpenGLRenderer","__clearShader",0x0d924440,"openfl.display.OpenGLRenderer.__clearShader","openfl/display/OpenGLRenderer.hx",458,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_482___copyShader,"openfl.display.OpenGLRenderer","__copyShader",0xf6e5bccc,"openfl.display.OpenGLRenderer.__copyShader","openfl/display/OpenGLRenderer.hx",482,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_492___getMatrix,"openfl.display.OpenGLRenderer","__getMatrix",0x35fc4fa5,"openfl.display.OpenGLRenderer.__getMatrix","openfl/display/OpenGLRenderer.hx",492,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_527___initShader,"openfl.display.OpenGLRenderer","__initShader",0x4566b267,"openfl.display.OpenGLRenderer.__initShader","openfl/display/OpenGLRenderer.hx",527,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_550___initDisplayShader,"openfl.display.OpenGLRenderer","__initDisplayShader",0x1a335405,"openfl.display.OpenGLRenderer.__initDisplayShader","openfl/display/OpenGLRenderer.hx",550,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_573___initGraphicsShader,"openfl.display.OpenGLRenderer","__initGraphicsShader",0x6e1a5b92,"openfl.display.OpenGLRenderer.__initGraphicsShader","openfl/display/OpenGLRenderer.hx",573,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_596___initShaderBuffer,"openfl.display.OpenGLRenderer","__initShaderBuffer",0x02c42ac7,"openfl.display.OpenGLRenderer.__initShaderBuffer","openfl/display/OpenGLRenderer.hx",596,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_609___popMask,"openfl.display.OpenGLRenderer","__popMask",0x3178efcb,"openfl.display.OpenGLRenderer.__popMask","openfl/display/OpenGLRenderer.hx",609,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_638___popMaskObject,"openfl.display.OpenGLRenderer","__popMaskObject",0x68af4cea,"openfl.display.OpenGLRenderer.__popMaskObject","openfl/display/OpenGLRenderer.hx",638,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_657___popMaskRect,"openfl.display.OpenGLRenderer","__popMaskRect",0x2af4aa8f,"openfl.display.OpenGLRenderer.__popMaskRect","openfl/display/OpenGLRenderer.hx",657,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_676___pushMask,"openfl.display.OpenGLRenderer","__pushMask",0xc3778378,"openfl.display.OpenGLRenderer.__pushMask","openfl/display/OpenGLRenderer.hx",676,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_702___pushMaskObject,"openfl.display.OpenGLRenderer","__pushMaskObject",0x7a5f6057,"openfl.display.OpenGLRenderer.__pushMaskObject","openfl/display/OpenGLRenderer.hx",702,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_719___pushMaskRect,"openfl.display.OpenGLRenderer","__pushMaskRect",0x178b18bc,"openfl.display.OpenGLRenderer.__pushMaskRect","openfl/display/OpenGLRenderer.hx",719,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_763___render,"openfl.display.OpenGLRenderer","__render",0x24141268,"openfl.display.OpenGLRenderer.__render","openfl/display/OpenGLRenderer.hx",763,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_831___renderFilterPass,"openfl.display.OpenGLRenderer","__renderFilterPass",0xd0419531,"openfl.display.OpenGLRenderer.__renderFilterPass","openfl/display/OpenGLRenderer.hx",831,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_867___renderStage3D,"openfl.display.OpenGLRenderer","__renderStage3D",0x0a0bf567,"openfl.display.OpenGLRenderer.__renderStage3D","openfl/display/OpenGLRenderer.hx",867,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_876___resize,"openfl.display.OpenGLRenderer","__resize",0x27660106,"openfl.display.OpenGLRenderer.__resize","openfl/display/OpenGLRenderer.hx",876,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_900___resumeClipAndMask,"openfl.display.OpenGLRenderer","__resumeClipAndMask",0x7bcaa3f4,"openfl.display.OpenGLRenderer.__resumeClipAndMask","openfl/display/OpenGLRenderer.hx",900,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_927___scissorRect,"openfl.display.OpenGLRenderer","__scissorRect",0xbdd8570e,"openfl.display.OpenGLRenderer.__scissorRect","openfl/display/OpenGLRenderer.hx",927,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_950___setBlendMode,"openfl.display.OpenGLRenderer","__setBlendMode",0xc7ebe4e4,"openfl.display.OpenGLRenderer.__setBlendMode","openfl/display/OpenGLRenderer.hx",950,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_1000___setRenderTarget,"openfl.display.OpenGLRenderer","__setRenderTarget",0xe23db0b7,"openfl.display.OpenGLRenderer.__setRenderTarget","openfl/display/OpenGLRenderer.hx",1000,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_1014___setShaderBuffer,"openfl.display.OpenGLRenderer","__setShaderBuffer",0x2c781375,"openfl.display.OpenGLRenderer.__setShaderBuffer","openfl/display/OpenGLRenderer.hx",1014,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_1022___suspendClipAndMask,"openfl.display.OpenGLRenderer","__suspendClipAndMask",0x40692e69,"openfl.display.OpenGLRenderer.__suspendClipAndMask","openfl/display/OpenGLRenderer.hx",1022,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_1041___updateShaderBuffer,"openfl.display.OpenGLRenderer","__updateShaderBuffer",0x07dc8fc0,"openfl.display.OpenGLRenderer.__updateShaderBuffer","openfl/display/OpenGLRenderer.hx",1041,0x89bd8a40)
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_57_boot,"openfl.display.OpenGLRenderer","boot",0x1be95f24,"openfl.display.OpenGLRenderer.boot","openfl/display/OpenGLRenderer.hx",57,0x89bd8a40)
static const Float _hx_array_data_fdf86abc_43[] = {
	1.,
};
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_58_boot,"openfl.display.OpenGLRenderer","boot",0x1be95f24,"openfl.display.OpenGLRenderer.boot","openfl/display/OpenGLRenderer.hx",58,0x89bd8a40)
static const Float _hx_array_data_fdf86abc_45[] = {
	(Float)0,(Float)0,(Float)0,0.,
};
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_59_boot,"openfl.display.OpenGLRenderer","boot",0x1be95f24,"openfl.display.OpenGLRenderer.boot","openfl/display/OpenGLRenderer.hx",59,0x89bd8a40)
static const Float _hx_array_data_fdf86abc_47[] = {
	(Float)0,(Float)0,(Float)0,0.,
};
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_60_boot,"openfl.display.OpenGLRenderer","boot",0x1be95f24,"openfl.display.OpenGLRenderer.boot","openfl/display/OpenGLRenderer.hx",60,0x89bd8a40)
static const Float _hx_array_data_fdf86abc_49[] = {
	(Float)1,(Float)1,(Float)1,1.,
};
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_61_boot,"openfl.display.OpenGLRenderer","boot",0x1be95f24,"openfl.display.OpenGLRenderer.boot","openfl/display/OpenGLRenderer.hx",61,0x89bd8a40)
static const Float _hx_array_data_fdf86abc_51[] = {
	(Float)0,(Float)0,(Float)0,0.,
};
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_62_boot,"openfl.display.OpenGLRenderer","boot",0x1be95f24,"openfl.display.OpenGLRenderer.boot","openfl/display/OpenGLRenderer.hx",62,0x89bd8a40)
static const Float _hx_array_data_fdf86abc_53[] = {
	1.,
};
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_63_boot,"openfl.display.OpenGLRenderer","boot",0x1be95f24,"openfl.display.OpenGLRenderer.boot","openfl/display/OpenGLRenderer.hx",63,0x89bd8a40)
static const bool _hx_array_data_fdf86abc_55[] = {
	0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_2f59d7e567bca573_64_boot,"openfl.display.OpenGLRenderer","boot",0x1be95f24,"openfl.display.OpenGLRenderer.boot","openfl/display/OpenGLRenderer.hx",64,0x89bd8a40)
static const Float _hx_array_data_fdf86abc_57[] = {
	(Float)0,0.,
};
namespace openfl{
namespace display{

void OpenGLRenderer_obj::__construct( ::lime::graphics::RenderContext context, ::openfl::display::BitmapData defaultRenderTarget){
            	HX_GC_STACKFRAME(&_hx_pos_2f59d7e567bca573_106_new)
HXLINE( 108)		super::__construct();
HXLINE( 111)		this->gl = context->webgl;
HXLINE( 112)		this->_hx___gl = this->gl;
HXLINE( 118)		this->_hx___context = context;
HXLINE( 120)		this->_hx___defaultRenderTarget = defaultRenderTarget;
HXLINE( 121)		this->_hx___flipped = hx::IsNull( this->_hx___defaultRenderTarget );
HXLINE( 123)		if (hx::IsNull( ::openfl::display::Graphics_obj::maxTextureWidth )) {
HXLINE( 125)			::openfl::display::Graphics_obj::maxTextureWidth = (::openfl::display::Graphics_obj::maxTextureHeight = this->_hx___gl->getParameter(this->_hx___gl->MAX_TEXTURE_SIZE));
            		}
HXLINE( 129)		this->_hx___matrix = ::lime::math::_Matrix4::Matrix4_Impl__obj::_new(null());
HXLINE( 130)		this->_hx___values = ::Array_obj< Float >::__new();
HXLINE( 145)		this->_hx___softwareRenderer =  ::openfl::display::CairoRenderer_obj::__alloc( HX_CTX ,null());
HXLINE( 148)		this->_hx___type = HX_("opengl",6f,64,94,21);
HXLINE( 150)		this->_hx___setBlendMode((int)10);
HXLINE( 151)		this->_hx___gl->enable(this->_hx___gl->BLEND);
HXLINE( 153)		this->_hx___clipRects = ::Array_obj< ::Dynamic>::__new();
HXLINE( 154)		this->_hx___maskObjects = ::Array_obj< ::Dynamic>::__new();
HXLINE( 155)		this->_hx___numClipRects = (int)0;
HXLINE( 156)		this->_hx___projection = ::lime::math::_Matrix4::Matrix4_Impl__obj::_new(null());
HXLINE( 157)		this->_hx___projectionFlipped = ::lime::math::_Matrix4::Matrix4_Impl__obj::_new(null());
HXLINE( 158)		this->_hx___stencilReference = (int)0;
HXLINE( 159)		this->_hx___tempRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 161)		this->_hx___defaultDisplayShader =  ::openfl::display::DisplayObjectShader_obj::__alloc( HX_CTX ,null());
HXLINE( 162)		this->_hx___defaultGraphicsShader =  ::openfl::display::GraphicsShader_obj::__alloc( HX_CTX ,null());
HXLINE( 163)		this->_hx___defaultShader = this->_hx___defaultDisplayShader;
HXLINE( 165)		this->_hx___initShader(this->_hx___defaultShader);
HXLINE( 167)		this->_hx___maskShader =  ::openfl::_internal::renderer::opengl::GLMaskShader_obj::__alloc( HX_CTX );
            	}

Dynamic OpenGLRenderer_obj::__CreateEmpty() { return new OpenGLRenderer_obj; }

void *OpenGLRenderer_obj::_hx_vtable = 0;

Dynamic OpenGLRenderer_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< OpenGLRenderer_obj > _hx_result = new OpenGLRenderer_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool OpenGLRenderer_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x38ea65a4) {
		if (inClassId<=(int)0x1b123bf8) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x1b123bf8;
		} else {
			return inClassId==(int)0x38ea65a4;
		}
	} else {
		return inClassId==(int)0x7cdf41d6;
	}
}

void OpenGLRenderer_obj::applyAlpha(Float alpha){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_172_applyAlpha)
HXLINE( 174)		::openfl::display::OpenGLRenderer_obj::_hx___alphaValue[(int)0] = alpha;
HXLINE( 176)		if (hx::IsNotNull( this->_hx___currentShaderBuffer )) {
HXLINE( 178)			this->_hx___currentShaderBuffer->addOverride(HX_("openfl_Alpha",0f,ce,3e,6a),::openfl::display::OpenGLRenderer_obj::_hx___alphaValue);
            		}
            		else {
HXLINE( 180)			if (hx::IsNotNull( this->_hx___currentShader )) {
HXLINE( 182)				if (hx::IsNotNull( this->_hx___currentShader->_hx___alpha )) {
HXLINE( 182)					this->_hx___currentShader->_hx___alpha->value = ::openfl::display::OpenGLRenderer_obj::_hx___alphaValue;
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,applyAlpha,(void))

void OpenGLRenderer_obj::applyBitmapData( ::openfl::display::BitmapData bitmapData,bool smooth,hx::Null< bool >  __o_repeat){
bool repeat = __o_repeat.Default(false);
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_191_applyBitmapData)
HXDLIN( 191)		if (hx::IsNotNull( this->_hx___currentShaderBuffer )) {
HXLINE( 193)			if (hx::IsNotNull( bitmapData )) {
HXLINE( 195)				::openfl::display::OpenGLRenderer_obj::_hx___textureSizeValue[(int)0] = bitmapData->_hx___textureWidth;
HXLINE( 196)				::openfl::display::OpenGLRenderer_obj::_hx___textureSizeValue[(int)1] = bitmapData->_hx___textureHeight;
HXLINE( 198)				this->_hx___currentShaderBuffer->addOverride(HX_("openfl_TextureSize",ad,60,72,29),::openfl::display::OpenGLRenderer_obj::_hx___textureSizeValue);
            			}
            		}
            		else {
HXLINE( 202)			if (hx::IsNotNull( this->_hx___currentShader )) {
HXLINE( 204)				if (hx::IsNotNull( this->_hx___currentShader->_hx___bitmap )) {
HXLINE( 206)					this->_hx___currentShader->_hx___bitmap->input = bitmapData;
HXLINE( 207)					 ::Dynamic _hx_tmp;
HXDLIN( 207)					if (smooth) {
HXLINE( 207)						_hx_tmp = (int)4;
            					}
            					else {
HXLINE( 207)						_hx_tmp = (int)5;
            					}
HXDLIN( 207)					this->_hx___currentShader->_hx___bitmap->filter = _hx_tmp;
HXLINE( 208)					this->_hx___currentShader->_hx___bitmap->mipFilter = (int)2;
HXLINE( 209)					 ::Dynamic _hx_tmp1;
HXDLIN( 209)					if (repeat) {
HXLINE( 209)						_hx_tmp1 = (int)2;
            					}
            					else {
HXLINE( 209)						_hx_tmp1 = (int)0;
            					}
HXDLIN( 209)					this->_hx___currentShader->_hx___bitmap->wrap = _hx_tmp1;
            				}
HXLINE( 213)				if (hx::IsNotNull( this->_hx___currentShader->_hx___texture )) {
HXLINE( 215)					this->_hx___currentShader->_hx___texture->input = bitmapData;
HXLINE( 216)					 ::Dynamic _hx_tmp2;
HXDLIN( 216)					if (smooth) {
HXLINE( 216)						_hx_tmp2 = (int)4;
            					}
            					else {
HXLINE( 216)						_hx_tmp2 = (int)5;
            					}
HXDLIN( 216)					this->_hx___currentShader->_hx___texture->filter = _hx_tmp2;
HXLINE( 217)					this->_hx___currentShader->_hx___texture->mipFilter = (int)2;
HXLINE( 218)					 ::Dynamic _hx_tmp3;
HXDLIN( 218)					if (repeat) {
HXLINE( 218)						_hx_tmp3 = (int)2;
            					}
            					else {
HXLINE( 218)						_hx_tmp3 = (int)0;
            					}
HXDLIN( 218)					this->_hx___currentShader->_hx___texture->wrap = _hx_tmp3;
            				}
HXLINE( 222)				if (hx::IsNotNull( this->_hx___currentShader->_hx___textureSize )) {
HXLINE( 224)					if (hx::IsNotNull( bitmapData )) {
HXLINE( 226)						::openfl::display::OpenGLRenderer_obj::_hx___textureSizeValue[(int)0] = bitmapData->_hx___textureWidth;
HXLINE( 227)						::openfl::display::OpenGLRenderer_obj::_hx___textureSizeValue[(int)1] = bitmapData->_hx___textureHeight;
HXLINE( 229)						this->_hx___currentShader->_hx___textureSize->value = ::openfl::display::OpenGLRenderer_obj::_hx___textureSizeValue;
            					}
            					else {
HXLINE( 233)						this->_hx___currentShader->_hx___textureSize->value = null();
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(OpenGLRenderer_obj,applyBitmapData,(void))

void OpenGLRenderer_obj::applyColorTransform( ::openfl::geom::ColorTransform colorTransform){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_244_applyColorTransform)
HXLINE( 246)		bool enabled;
HXDLIN( 246)		if (hx::IsNotNull( colorTransform )) {
HXLINE( 246)			enabled = !(colorTransform->_hx___isDefault());
            		}
            		else {
HXLINE( 246)			enabled = false;
            		}
HXLINE( 247)		this->applyHasColorTransform(enabled);
HXLINE( 249)		if (enabled) {
HXLINE( 251)			colorTransform->_hx___setArrays(::openfl::display::OpenGLRenderer_obj::_hx___colorMultipliersValue,::openfl::display::OpenGLRenderer_obj::_hx___colorOffsetsValue);
HXLINE( 253)			if (hx::IsNotNull( this->_hx___currentShaderBuffer )) {
HXLINE( 255)				this->_hx___currentShaderBuffer->addOverride(HX_("openfl_ColorMultiplier",b5,e4,dc,18),::openfl::display::OpenGLRenderer_obj::_hx___colorMultipliersValue);
HXLINE( 256)				this->_hx___currentShaderBuffer->addOverride(HX_("openfl_ColorOffset",c7,ea,07,41),::openfl::display::OpenGLRenderer_obj::_hx___colorOffsetsValue);
            			}
            			else {
HXLINE( 258)				if (hx::IsNotNull( this->_hx___currentShader )) {
HXLINE( 260)					if (hx::IsNotNull( this->_hx___currentShader->_hx___colorMultiplier )) {
HXLINE( 260)						this->_hx___currentShader->_hx___colorMultiplier->value = ::openfl::display::OpenGLRenderer_obj::_hx___colorMultipliersValue;
            					}
HXLINE( 261)					if (hx::IsNotNull( this->_hx___currentShader->_hx___colorOffset )) {
HXLINE( 261)						this->_hx___currentShader->_hx___colorOffset->value = ::openfl::display::OpenGLRenderer_obj::_hx___colorOffsetsValue;
            					}
            				}
            			}
            		}
            		else {
HXLINE( 267)			if (hx::IsNotNull( this->_hx___currentShaderBuffer )) {
HXLINE( 269)				this->_hx___currentShaderBuffer->addOverride(HX_("openfl_ColorMultiplier",b5,e4,dc,18),::openfl::display::OpenGLRenderer_obj::_hx___emptyColorValue);
HXLINE( 270)				this->_hx___currentShaderBuffer->addOverride(HX_("openfl_ColorOffset",c7,ea,07,41),::openfl::display::OpenGLRenderer_obj::_hx___emptyColorValue);
            			}
            			else {
HXLINE( 272)				if (hx::IsNotNull( this->_hx___currentShader )) {
HXLINE( 274)					if (hx::IsNotNull( this->_hx___currentShader->_hx___colorMultiplier )) {
HXLINE( 274)						this->_hx___currentShader->_hx___colorMultiplier->value = ::openfl::display::OpenGLRenderer_obj::_hx___emptyColorValue;
            					}
HXLINE( 275)					if (hx::IsNotNull( this->_hx___currentShader->_hx___colorOffset )) {
HXLINE( 275)						this->_hx___currentShader->_hx___colorOffset->value = ::openfl::display::OpenGLRenderer_obj::_hx___emptyColorValue;
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,applyColorTransform,(void))

void OpenGLRenderer_obj::applyHasColorTransform(bool enabled){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_284_applyHasColorTransform)
HXLINE( 286)		::openfl::display::OpenGLRenderer_obj::_hx___hasColorTransformValue[(int)0] = enabled;
HXLINE( 288)		if (hx::IsNotNull( this->_hx___currentShaderBuffer )) {
HXLINE( 290)			this->_hx___currentShaderBuffer->addOverride(HX_("openfl_HasColorTransform",b4,00,4b,62),::openfl::display::OpenGLRenderer_obj::_hx___hasColorTransformValue);
            		}
            		else {
HXLINE( 292)			if (hx::IsNotNull( this->_hx___currentShader )) {
HXLINE( 294)				if (hx::IsNotNull( this->_hx___currentShader->_hx___hasColorTransform )) {
HXLINE( 294)					this->_hx___currentShader->_hx___hasColorTransform->value = ::openfl::display::OpenGLRenderer_obj::_hx___hasColorTransformValue;
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,applyHasColorTransform,(void))

void OpenGLRenderer_obj::applyMatrix(::Array< Float > matrix){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_303_applyMatrix)
HXDLIN( 303)		if (hx::IsNotNull( this->_hx___currentShaderBuffer )) {
HXLINE( 305)			this->_hx___currentShaderBuffer->addOverride(HX_("openfl_Matrix",70,ea,41,06),matrix);
            		}
            		else {
HXLINE( 307)			if (hx::IsNotNull( this->_hx___currentShader )) {
HXLINE( 309)				if (hx::IsNotNull( this->_hx___currentShader->_hx___matrix )) {
HXLINE( 309)					this->_hx___currentShader->_hx___matrix->value = matrix;
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,applyMatrix,(void))

 ::lime::utils::ArrayBufferView OpenGLRenderer_obj::getMatrix( ::openfl::geom::Matrix transform){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_318_getMatrix)
HXDLIN( 318)		if (hx::IsNotNull( this->gl )) {
HXLINE( 320)			::Array< Float > values = this->_hx___getMatrix(transform);
HXLINE( 322)			{
HXLINE( 322)				int _g = (int)0;
HXDLIN( 322)				while((_g < (int)16)){
HXLINE( 322)					_g = (_g + (int)1);
HXDLIN( 322)					int i = (_g - (int)1);
HXLINE( 324)					 ::lime::utils::ArrayBufferView _hx_tmp = this->_hx___matrix;
HXDLIN( 324)					::lime::math::_Matrix4::Matrix4_Impl__obj::set(_hx_tmp,i,values->__get(i));
            				}
            			}
HXLINE( 328)			return this->_hx___matrix;
            		}
            		else {
HXLINE( 332)			::lime::math::_Matrix4::Matrix4_Impl__obj::identity(this->_hx___matrix);
HXLINE( 333)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(this->_hx___matrix,(int)0,transform->a);
HXLINE( 334)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(this->_hx___matrix,(int)1,transform->b);
HXLINE( 335)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(this->_hx___matrix,(int)4,transform->c);
HXLINE( 336)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(this->_hx___matrix,(int)5,transform->d);
HXLINE( 337)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(this->_hx___matrix,(int)12,transform->tx);
HXLINE( 338)			::lime::math::_Matrix4::Matrix4_Impl__obj::set(this->_hx___matrix,(int)13,transform->ty);
HXLINE( 340)			return this->_hx___matrix;
            		}
HXLINE( 318)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,getMatrix,return )

void OpenGLRenderer_obj::setShader( ::openfl::display::Shader shader){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_347_setShader)
HXLINE( 349)		this->_hx___currentShaderBuffer = null();
HXLINE( 351)		if (hx::IsEq( this->_hx___currentShader,shader )) {
HXLINE( 351)			return;
            		}
HXLINE( 353)		if (hx::IsNotNull( this->_hx___currentShader )) {
HXLINE( 355)			this->_hx___currentShader->_hx___disable();
            		}
HXLINE( 359)		if (hx::IsNull( shader )) {
HXLINE( 361)			this->_hx___currentShader = null();
HXLINE( 362)			this->_hx___gl->useProgram(null());
HXLINE( 363)			return;
            		}
            		else {
HXLINE( 367)			this->_hx___currentShader = shader;
HXLINE( 368)			this->_hx___initShader(shader);
HXLINE( 369)			this->_hx___gl->useProgram(shader->glProgram);
HXLINE( 370)			this->_hx___currentShader->_hx___enable();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,setShader,(void))

void OpenGLRenderer_obj::setViewport(){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_379_setViewport)
HXDLIN( 379)		this->_hx___gl->viewport(this->_hx___offsetX,this->_hx___offsetY,this->_hx___displayWidth,this->_hx___displayHeight);
            	}


HX_DEFINE_DYNAMIC_FUNC0(OpenGLRenderer_obj,setViewport,(void))

void OpenGLRenderer_obj::updateShader(){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_386_updateShader)
HXDLIN( 386)		if (hx::IsNotNull( this->_hx___currentShader )) {
HXLINE( 388)			if (hx::IsNotNull( this->_hx___currentShader->_hx___position )) {
HXLINE( 388)				this->_hx___currentShader->_hx___position->_hx___useArray = true;
            			}
HXLINE( 389)			if (hx::IsNotNull( this->_hx___currentShader->_hx___textureCoord )) {
HXLINE( 389)				this->_hx___currentShader->_hx___textureCoord->_hx___useArray = true;
            			}
HXLINE( 390)			this->_hx___currentShader->_hx___update();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(OpenGLRenderer_obj,updateShader,(void))

void OpenGLRenderer_obj::useAlphaArray(){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_399_useAlphaArray)
HXDLIN( 399)		if (hx::IsNotNull( this->_hx___currentShader )) {
HXLINE( 401)			if (hx::IsNotNull( this->_hx___currentShader->_hx___alpha )) {
HXLINE( 401)				this->_hx___currentShader->_hx___alpha->_hx___useArray = true;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(OpenGLRenderer_obj,useAlphaArray,(void))

void OpenGLRenderer_obj::useColorTransformArray(){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_410_useColorTransformArray)
HXDLIN( 410)		if (hx::IsNotNull( this->_hx___currentShader )) {
HXLINE( 412)			if (hx::IsNotNull( this->_hx___currentShader->_hx___colorMultiplier )) {
HXLINE( 412)				this->_hx___currentShader->_hx___colorMultiplier->_hx___useArray = true;
            			}
HXLINE( 413)			if (hx::IsNotNull( this->_hx___currentShader->_hx___colorOffset )) {
HXLINE( 413)				this->_hx___currentShader->_hx___colorOffset->_hx___useArray = true;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(OpenGLRenderer_obj,useColorTransformArray,(void))

void OpenGLRenderer_obj::_hx___cleanup(){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_420___cleanup)
HXLINE( 422)		if ((this->_hx___stencilReference > (int)0)) {
HXLINE( 424)			this->_hx___stencilReference = (int)0;
HXLINE( 425)			this->_hx___gl->disable(this->_hx___gl->STENCIL_TEST);
            		}
HXLINE( 429)		if ((this->_hx___numClipRects > (int)0)) {
HXLINE( 431)			this->_hx___numClipRects = (int)0;
HXLINE( 432)			this->_hx___scissorRect(null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(OpenGLRenderer_obj,_hx___cleanup,(void))

void OpenGLRenderer_obj::_hx___clear(){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_439___clear)
HXLINE( 441)		bool _hx_tmp;
HXDLIN( 441)		if (hx::IsNotNull( this->_hx___stage )) {
HXLINE( 441)			_hx_tmp = this->_hx___stage->_hx___transparent;
            		}
            		else {
HXLINE( 441)			_hx_tmp = true;
            		}
HXDLIN( 441)		if (_hx_tmp) {
HXLINE( 443)			this->_hx___gl->clearColor((int)0,(int)0,(int)0,(int)0);
            		}
            		else {
HXLINE( 447)			this->_hx___gl->clearColor(this->_hx___stage->_hx___colorSplit->__get((int)0),this->_hx___stage->_hx___colorSplit->__get((int)1),this->_hx___stage->_hx___colorSplit->__get((int)2),(int)1);
            		}
HXLINE( 451)		this->_hx___gl->clear(this->_hx___gl->COLOR_BUFFER_BIT);
            	}


void OpenGLRenderer_obj::_hx___clearShader(){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_458___clearShader)
HXDLIN( 458)		if (hx::IsNotNull( this->_hx___currentShader )) {
HXLINE( 460)			if (hx::IsNull( this->_hx___currentShaderBuffer )) {
HXLINE( 462)				if (hx::IsNotNull( this->_hx___currentShader->_hx___bitmap )) {
HXLINE( 462)					this->_hx___currentShader->_hx___bitmap->input = null();
            				}
            			}
            			else {
HXLINE( 466)				this->_hx___currentShaderBuffer->clearOverride();
            			}
HXLINE( 470)			if (hx::IsNotNull( this->_hx___currentShader->_hx___texture )) {
HXLINE( 470)				this->_hx___currentShader->_hx___texture->input = null();
            			}
HXLINE( 471)			if (hx::IsNotNull( this->_hx___currentShader->_hx___textureSize )) {
HXLINE( 471)				this->_hx___currentShader->_hx___textureSize->value = null();
            			}
HXLINE( 472)			if (hx::IsNotNull( this->_hx___currentShader->_hx___hasColorTransform )) {
HXLINE( 472)				this->_hx___currentShader->_hx___hasColorTransform->value = null();
            			}
HXLINE( 473)			if (hx::IsNotNull( this->_hx___currentShader->_hx___position )) {
HXLINE( 473)				this->_hx___currentShader->_hx___position->value = null();
            			}
HXLINE( 474)			if (hx::IsNotNull( this->_hx___currentShader->_hx___matrix )) {
HXLINE( 474)				this->_hx___currentShader->_hx___matrix->value = null();
            			}
HXLINE( 475)			this->_hx___currentShader->_hx___clearUseArray();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(OpenGLRenderer_obj,_hx___clearShader,(void))

void OpenGLRenderer_obj::_hx___copyShader( ::openfl::display::OpenGLRenderer other){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_482___copyShader)
HXLINE( 484)		this->_hx___currentShader = other->_hx___currentShader;
HXLINE( 485)		this->_hx___currentShaderBuffer = other->_hx___currentShaderBuffer;
HXLINE( 486)		this->_hx___currentDisplayShader = other->_hx___currentDisplayShader;
HXLINE( 487)		this->_hx___currentGraphicsShader = other->_hx___currentGraphicsShader;
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,_hx___copyShader,(void))

::Array< Float > OpenGLRenderer_obj::_hx___getMatrix( ::openfl::geom::Matrix transform){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_492___getMatrix)
HXLINE( 494)		 ::openfl::geom::Matrix _matrix = ::openfl::geom::Matrix_obj::_hx___pool->get();
HXLINE( 495)		_matrix->copyFrom(transform);
HXLINE( 496)		_matrix->concat(this->_hx___worldTransform);
HXLINE( 498)		if (this->_hx___roundPixels) {
HXLINE( 500)			_matrix->tx = ::Math_obj::round(_matrix->tx);
HXLINE( 501)			_matrix->ty = ::Math_obj::round(_matrix->ty);
            		}
HXLINE( 505)		::lime::math::_Matrix4::Matrix4_Impl__obj::identity(this->_hx___matrix);
HXLINE( 506)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(this->_hx___matrix,(int)0,_matrix->a);
HXLINE( 507)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(this->_hx___matrix,(int)1,_matrix->b);
HXLINE( 508)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(this->_hx___matrix,(int)4,_matrix->c);
HXLINE( 509)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(this->_hx___matrix,(int)5,_matrix->d);
HXLINE( 510)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(this->_hx___matrix,(int)12,_matrix->tx);
HXLINE( 511)		::lime::math::_Matrix4::Matrix4_Impl__obj::set(this->_hx___matrix,(int)13,_matrix->ty);
HXLINE( 512)		 ::lime::utils::ArrayBufferView _hx_tmp;
HXDLIN( 512)		if (this->_hx___flipped) {
HXLINE( 512)			_hx_tmp = this->_hx___projectionFlipped;
            		}
            		else {
HXLINE( 512)			_hx_tmp = this->_hx___projection;
            		}
HXDLIN( 512)		::lime::math::_Matrix4::Matrix4_Impl__obj::append(this->_hx___matrix,_hx_tmp);
HXLINE( 514)		{
HXLINE( 514)			int _g = (int)0;
HXDLIN( 514)			while((_g < (int)16)){
HXLINE( 514)				_g = (_g + (int)1);
HXDLIN( 514)				int i = (_g - (int)1);
HXLINE( 516)				::Array< Float > _hx_tmp1 = this->_hx___values;
HXDLIN( 516)				_hx_tmp1[i] = ::lime::math::_Matrix4::Matrix4_Impl__obj::get(this->_hx___matrix,i);
            			}
            		}
HXLINE( 520)		::openfl::geom::Matrix_obj::_hx___pool->release(_matrix);
HXLINE( 522)		return this->_hx___values;
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,_hx___getMatrix,return )

 ::openfl::display::Shader OpenGLRenderer_obj::_hx___initShader( ::openfl::display::Shader shader){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_527___initShader)
HXLINE( 529)		if (hx::IsNotNull( shader )) {
HXLINE( 533)			if (hx::IsNull( shader->_hx___context )) {
HXLINE( 535)				shader->_hx___context = this->_hx___context;
HXLINE( 536)				shader->_hx___init();
            			}
HXLINE( 541)			return shader;
            		}
HXLINE( 545)		return this->_hx___defaultShader;
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,_hx___initShader,return )

 ::openfl::display::Shader OpenGLRenderer_obj::_hx___initDisplayShader( ::openfl::display::Shader shader){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_550___initDisplayShader)
HXLINE( 552)		if (hx::IsNotNull( shader )) {
HXLINE( 556)			if (hx::IsNull( shader->_hx___context )) {
HXLINE( 558)				shader->_hx___context = this->_hx___context;
HXLINE( 559)				shader->_hx___init();
            			}
HXLINE( 564)			return shader;
            		}
HXLINE( 568)		return this->_hx___defaultDisplayShader;
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,_hx___initDisplayShader,return )

 ::openfl::display::Shader OpenGLRenderer_obj::_hx___initGraphicsShader( ::openfl::display::Shader shader){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_573___initGraphicsShader)
HXLINE( 575)		if (hx::IsNotNull( shader )) {
HXLINE( 579)			if (hx::IsNull( shader->_hx___context )) {
HXLINE( 581)				shader->_hx___context = this->_hx___context;
HXLINE( 582)				shader->_hx___init();
            			}
HXLINE( 587)			return shader;
            		}
HXLINE( 591)		return this->_hx___defaultGraphicsShader;
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,_hx___initGraphicsShader,return )

 ::openfl::display::Shader OpenGLRenderer_obj::_hx___initShaderBuffer( ::openfl::_internal::renderer::ShaderBuffer shaderBuffer){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_596___initShaderBuffer)
HXLINE( 598)		if (hx::IsNotNull( shaderBuffer )) {
HXLINE( 600)			return this->_hx___initGraphicsShader(shaderBuffer->shader);
            		}
HXLINE( 604)		return this->_hx___defaultGraphicsShader;
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,_hx___initShaderBuffer,return )

void OpenGLRenderer_obj::_hx___popMask(){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_609___popMask)
HXLINE( 611)		if ((this->_hx___stencilReference == (int)0)) {
HXLINE( 611)			return;
            		}
HXLINE( 613)		 ::openfl::display::DisplayObject mask = this->_hx___maskObjects->pop().StaticCast<  ::openfl::display::DisplayObject >();
HXLINE( 615)		if ((this->_hx___stencilReference > (int)1)) {
HXLINE( 617)			this->_hx___gl->stencilOp(this->_hx___gl->KEEP,this->_hx___gl->KEEP,this->_hx___gl->DECR);
HXLINE( 618)			this->_hx___gl->stencilFunc(this->_hx___gl->EQUAL,this->_hx___stencilReference,(int)255);
HXLINE( 619)			this->_hx___gl->colorMask(false,false,false,false);
HXLINE( 621)			mask->_hx___renderGLMask(hx::ObjectPtr<OBJ_>(this));
HXLINE( 622)			this->_hx___stencilReference--;
HXLINE( 624)			this->_hx___gl->stencilOp(this->_hx___gl->KEEP,this->_hx___gl->KEEP,this->_hx___gl->KEEP);
HXLINE( 625)			this->_hx___gl->stencilFunc(this->_hx___gl->EQUAL,this->_hx___stencilReference,(int)255);
HXLINE( 626)			this->_hx___gl->colorMask(true,true,true,true);
            		}
            		else {
HXLINE( 630)			this->_hx___stencilReference = (int)0;
HXLINE( 631)			this->_hx___gl->disable(this->_hx___gl->STENCIL_TEST);
            		}
            	}


void OpenGLRenderer_obj::_hx___popMaskObject( ::openfl::display::DisplayObject object,hx::Null< bool >  __o_handleScrollRect){
bool handleScrollRect = __o_handleScrollRect.Default(true);
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_638___popMaskObject)
HXLINE( 640)		if (hx::IsNotNull( object->_hx___mask )) {
HXLINE( 642)			this->_hx___popMask();
            		}
HXLINE( 646)		bool _hx_tmp;
HXDLIN( 646)		if (handleScrollRect) {
HXLINE( 646)			_hx_tmp = hx::IsNotNull( object->_hx___scrollRect );
            		}
            		else {
HXLINE( 646)			_hx_tmp = false;
            		}
HXDLIN( 646)		if (_hx_tmp) {
HXLINE( 648)			this->_hx___popMaskRect();
            		}
            	}


void OpenGLRenderer_obj::_hx___popMaskRect(){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_657___popMaskRect)
HXDLIN( 657)		if ((this->_hx___numClipRects > (int)0)) {
HXLINE( 659)			this->_hx___numClipRects--;
HXLINE( 661)			if ((this->_hx___numClipRects > (int)0)) {
HXLINE( 663)				::Array< ::Dynamic> _hx_tmp = this->_hx___clipRects;
HXDLIN( 663)				this->_hx___scissorRect(_hx_tmp->__get((this->_hx___numClipRects - (int)1)).StaticCast<  ::openfl::geom::Rectangle >());
            			}
            			else {
HXLINE( 667)				this->_hx___scissorRect(null());
            			}
            		}
            	}


void OpenGLRenderer_obj::_hx___pushMask( ::openfl::display::DisplayObject mask){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_676___pushMask)
HXLINE( 678)		if ((this->_hx___stencilReference == (int)0)) {
HXLINE( 680)			this->_hx___gl->enable(this->_hx___gl->STENCIL_TEST);
HXLINE( 681)			this->_hx___gl->stencilMask((int)255);
HXLINE( 682)			this->_hx___gl->clear(this->_hx___gl->STENCIL_BUFFER_BIT);
HXLINE( 683)			this->_hx___updatedStencil = true;
            		}
HXLINE( 687)		this->_hx___gl->stencilOp(this->_hx___gl->KEEP,this->_hx___gl->KEEP,this->_hx___gl->INCR);
HXLINE( 688)		this->_hx___gl->stencilFunc(this->_hx___gl->EQUAL,this->_hx___stencilReference,(int)255);
HXLINE( 689)		this->_hx___gl->colorMask(false,false,false,false);
HXLINE( 691)		mask->_hx___renderGLMask(hx::ObjectPtr<OBJ_>(this));
HXLINE( 692)		this->_hx___maskObjects->push(mask);
HXLINE( 693)		this->_hx___stencilReference++;
HXLINE( 695)		this->_hx___gl->stencilOp(this->_hx___gl->KEEP,this->_hx___gl->KEEP,this->_hx___gl->KEEP);
HXLINE( 696)		this->_hx___gl->stencilFunc(this->_hx___gl->EQUAL,this->_hx___stencilReference,(int)255);
HXLINE( 697)		this->_hx___gl->colorMask(true,true,true,true);
            	}


void OpenGLRenderer_obj::_hx___pushMaskObject( ::openfl::display::DisplayObject object,hx::Null< bool >  __o_handleScrollRect){
bool handleScrollRect = __o_handleScrollRect.Default(true);
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_702___pushMaskObject)
HXLINE( 704)		bool _hx_tmp;
HXDLIN( 704)		if (handleScrollRect) {
HXLINE( 704)			_hx_tmp = hx::IsNotNull( object->_hx___scrollRect );
            		}
            		else {
HXLINE( 704)			_hx_tmp = false;
            		}
HXDLIN( 704)		if (_hx_tmp) {
HXLINE( 706)			this->_hx___pushMaskRect(object->_hx___scrollRect,object->_hx___renderTransform);
            		}
HXLINE( 710)		if (hx::IsNotNull( object->_hx___mask )) {
HXLINE( 712)			this->_hx___pushMask(object->_hx___mask);
            		}
            	}


void OpenGLRenderer_obj::_hx___pushMaskRect( ::openfl::geom::Rectangle rect, ::openfl::geom::Matrix transform){
            	HX_GC_STACKFRAME(&_hx_pos_2f59d7e567bca573_719___pushMaskRect)
HXLINE( 723)		if ((this->_hx___numClipRects == this->_hx___clipRects->length)) {
HXLINE( 725)			::Array< ::Dynamic> _hx_tmp = this->_hx___clipRects;
HXDLIN( 725)			int _hx_tmp1 = this->_hx___numClipRects;
HXDLIN( 725)			_hx_tmp[_hx_tmp1] =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            		}
HXLINE( 729)		 ::openfl::geom::Matrix _matrix = ::openfl::geom::Matrix_obj::_hx___pool->get();
HXLINE( 730)		_matrix->copyFrom(transform);
HXLINE( 731)		_matrix->concat(this->_hx___worldTransform);
HXLINE( 733)		 ::openfl::geom::Rectangle clipRect = this->_hx___clipRects->__get(this->_hx___numClipRects).StaticCast<  ::openfl::geom::Rectangle >();
HXLINE( 734)		rect->_hx___transform(clipRect,_matrix);
HXLINE( 736)		if ((this->_hx___numClipRects > (int)0)) {
HXLINE( 738)			::Array< ::Dynamic> parentClipRect = this->_hx___clipRects;
HXDLIN( 738)			 ::openfl::geom::Rectangle parentClipRect1 = parentClipRect->__get((this->_hx___numClipRects - (int)1)).StaticCast<  ::openfl::geom::Rectangle >();
HXLINE( 739)			clipRect->_hx___contract(parentClipRect1->x,parentClipRect1->y,parentClipRect1->width,parentClipRect1->height);
            		}
HXLINE( 743)		if ((clipRect->height < (int)0)) {
HXLINE( 745)			clipRect->height = (int)0;
            		}
HXLINE( 749)		if ((clipRect->width < (int)0)) {
HXLINE( 751)			clipRect->width = (int)0;
            		}
HXLINE( 755)		::openfl::geom::Matrix_obj::_hx___pool->release(_matrix);
HXLINE( 757)		this->_hx___scissorRect(clipRect);
HXLINE( 758)		this->_hx___numClipRects++;
            	}


void OpenGLRenderer_obj::_hx___render(::Dynamic object){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_763___render)
HXLINE( 766)		this->_hx___gl->disable(this->_hx___gl->CULL_FACE);
HXLINE( 767)		this->_hx___gl->disable(this->_hx___gl->DEPTH_TEST);
HXLINE( 768)		this->_hx___gl->disable(this->_hx___gl->STENCIL_TEST);
HXLINE( 769)		this->_hx___gl->disable(this->_hx___gl->SCISSOR_TEST);
HXLINE( 771)		if (hx::IsNull( this->_hx___defaultRenderTarget )) {
HXLINE( 773)			this->_hx___gl->viewport(this->_hx___offsetX,this->_hx___offsetY,this->_hx___displayWidth,this->_hx___displayHeight);
HXLINE( 775)			bool _hx_tmp;
HXDLIN( 775)			if ((this->_hx___worldTransform->a == (int)1)) {
HXLINE( 775)				_hx_tmp = (this->_hx___worldTransform->d != (int)1);
            			}
            			else {
HXLINE( 775)				_hx_tmp = true;
            			}
HXDLIN( 775)			this->_hx___upscaled = _hx_tmp;
HXLINE( 777)			::openfl::display::IBitmapDrawable_obj::_hx___renderGL(object,hx::ObjectPtr<OBJ_>(this));
HXLINE( 779)			bool _hx_tmp1;
HXDLIN( 779)			if ((this->_hx___offsetX <= (int)0)) {
HXLINE( 779)				_hx_tmp1 = (this->_hx___offsetY > (int)0);
            			}
            			else {
HXLINE( 779)				_hx_tmp1 = true;
            			}
HXDLIN( 779)			if (_hx_tmp1) {
HXLINE( 781)				this->_hx___gl->clearColor((int)0,(int)0,(int)0,(int)1);
HXLINE( 782)				this->_hx___gl->enable(this->_hx___gl->SCISSOR_TEST);
HXLINE( 784)				if ((this->_hx___offsetX > (int)0)) {
HXLINE( 786)					this->_hx___gl->scissor((int)0,(int)0,this->_hx___offsetX,this->_hx___height);
HXLINE( 787)					this->_hx___gl->clear(this->_hx___gl->COLOR_BUFFER_BIT);
HXLINE( 789)					this->_hx___gl->scissor((this->_hx___offsetX + this->_hx___displayWidth),(int)0,this->_hx___width,this->_hx___height);
HXLINE( 790)					this->_hx___gl->clear(this->_hx___gl->COLOR_BUFFER_BIT);
            				}
HXLINE( 794)				if ((this->_hx___offsetY > (int)0)) {
HXLINE( 796)					this->_hx___gl->scissor((int)0,(int)0,this->_hx___width,this->_hx___offsetY);
HXLINE( 797)					this->_hx___gl->clear(this->_hx___gl->COLOR_BUFFER_BIT);
HXLINE( 799)					this->_hx___gl->scissor((int)0,(this->_hx___offsetY + this->_hx___displayHeight),this->_hx___width,this->_hx___height);
HXLINE( 800)					this->_hx___gl->clear(this->_hx___gl->COLOR_BUFFER_BIT);
            				}
HXLINE( 804)				this->_hx___gl->disable(this->_hx___gl->SCISSOR_TEST);
            			}
            		}
            		else {
HXLINE( 810)			this->_hx___gl->viewport(this->_hx___offsetX,this->_hx___offsetY,this->_hx___displayWidth,this->_hx___displayHeight);
HXLINE( 816)			 ::openfl::display::DisplayObject cacheMask = ( ( ::openfl::display::DisplayObject)(object->__Field(HX_("__mask",0c,a4,4e,f7),hx::paccDynamic)) );
HXLINE( 817)			 ::openfl::geom::Rectangle cacheScrollRect = ( ( ::openfl::geom::Rectangle)(object->__Field(HX_("__scrollRect",f1,56,fa,41),hx::paccDynamic)) );
HXLINE( 818)			object->__SetField(HX_("__mask",0c,a4,4e,f7),null(),hx::paccDynamic);
HXLINE( 819)			object->__SetField(HX_("__scrollRect",f1,56,fa,41),null(),hx::paccDynamic);
HXLINE( 821)			::openfl::display::IBitmapDrawable_obj::_hx___renderGL(object,hx::ObjectPtr<OBJ_>(this));
HXLINE( 823)			object->__SetField(HX_("__mask",0c,a4,4e,f7),cacheMask,hx::paccDynamic);
HXLINE( 824)			object->__SetField(HX_("__scrollRect",f1,56,fa,41),cacheScrollRect,hx::paccDynamic);
            		}
            	}


void OpenGLRenderer_obj::_hx___renderFilterPass( ::openfl::display::BitmapData source, ::openfl::display::Shader shader,hx::Null< bool >  __o_clear){
bool clear = __o_clear.Default(true);
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_831___renderFilterPass)
HXLINE( 833)		bool _hx_tmp;
HXDLIN( 833)		if (hx::IsNotNull( source )) {
HXLINE( 833)			_hx_tmp = hx::IsNull( shader );
            		}
            		else {
HXLINE( 833)			_hx_tmp = true;
            		}
HXDLIN( 833)		if (_hx_tmp) {
HXLINE( 833)			return;
            		}
HXLINE( 834)		if (hx::IsNull( this->_hx___defaultRenderTarget )) {
HXLINE( 834)			return;
            		}
HXLINE( 836)		{
HXLINE( 836)			 ::lime::_internal::backend::native::NativeOpenGLRenderContext this1 = this->_hx___gl;
HXDLIN( 836)			int target = this->_hx___gl->FRAMEBUFFER;
HXDLIN( 836)			this1->bindFramebuffer(target,this->_hx___defaultRenderTarget->_hx___getFramebuffer(this->_hx___context,false));
            		}
HXLINE( 838)		if (clear) {
HXLINE( 840)			this->_hx___gl->clearColor((int)0,(int)0,(int)0,(int)0);
HXLINE( 841)			this->_hx___gl->clear(this->_hx___gl->COLOR_BUFFER_BIT);
            		}
HXLINE( 845)		 ::openfl::display::Shader shader1 = this->_hx___initShader(shader);
HXLINE( 846)		this->setShader(shader1);
HXLINE( 847)		this->applyAlpha((int)1);
HXLINE( 848)		this->applyBitmapData(source,false,null());
HXLINE( 849)		this->applyColorTransform(null());
HXLINE( 850)		this->applyMatrix(this->_hx___getMatrix(source->_hx___renderTransform));
HXLINE( 851)		this->updateShader();
HXLINE( 853)		{
HXLINE( 853)			 ::lime::_internal::backend::native::NativeOpenGLRenderContext this2 = this->_hx___gl;
HXDLIN( 853)			int target1 = this->_hx___gl->ARRAY_BUFFER;
HXDLIN( 853)			this2->bindBuffer(target1,source->getBuffer(this->_hx___context));
            		}
HXLINE( 854)		if (hx::IsNotNull( shader1->_hx___position )) {
HXLINE( 854)			 ::lime::_internal::backend::native::NativeOpenGLRenderContext this3 = this->_hx___gl;
HXDLIN( 854)			int indx = shader1->_hx___position->index;
HXDLIN( 854)			int type = this->_hx___gl->FLOAT;
HXDLIN( 854)			this3->vertexAttribPointer(indx,(int)3,type,false,(int)56,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt((int)0));
            		}
HXLINE( 855)		if (hx::IsNotNull( shader1->_hx___textureCoord )) {
HXLINE( 855)			 ::lime::_internal::backend::native::NativeOpenGLRenderContext this4 = this->_hx___gl;
HXDLIN( 855)			int indx1 = shader1->_hx___textureCoord->index;
HXDLIN( 855)			int type1 = this->_hx___gl->FLOAT;
HXDLIN( 855)			this4->vertexAttribPointer(indx1,(int)2,type1,false,(int)56,::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt((int)12));
            		}
HXLINE( 856)		this->_hx___gl->drawArrays(this->_hx___gl->TRIANGLE_STRIP,(int)0,(int)4);
HXLINE( 858)		this->_hx___gl->bindFramebuffer(this->_hx___gl->FRAMEBUFFER,null());
HXLINE( 860)		this->_hx___clearShader();
            	}


HX_DEFINE_DYNAMIC_FUNC3(OpenGLRenderer_obj,_hx___renderFilterPass,(void))

void OpenGLRenderer_obj::_hx___renderStage3D( ::openfl::display::Stage stage){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_867___renderStage3D)
HXDLIN( 867)		int _g = (int)0;
HXDLIN( 867)		 ::openfl::_Vector::ObjectVector _g1 = stage->stage3Ds;
HXDLIN( 867)		while((_g < _g1->get_length())){
HXDLIN( 867)			 ::openfl::display::Stage3D stage3D = _g1->get(_g).StaticCast<  ::openfl::display::Stage3D >();
HXDLIN( 867)			_g = (_g + (int)1);
HXLINE( 869)			stage3D->_hx___renderGL(stage,hx::ObjectPtr<OBJ_>(this));
            		}
            	}


void OpenGLRenderer_obj::_hx___resize(int width,int height){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_876___resize)
HXLINE( 878)		this->_hx___width = width;
HXLINE( 879)		this->_hx___height = height;
HXLINE( 881)		int w;
HXDLIN( 881)		if (hx::IsNull( this->_hx___defaultRenderTarget )) {
HXLINE( 881)			w = this->_hx___stage->stageWidth;
            		}
            		else {
HXLINE( 881)			w = this->_hx___defaultRenderTarget->width;
            		}
HXLINE( 882)		int h;
HXDLIN( 882)		if (hx::IsNull( this->_hx___defaultRenderTarget )) {
HXLINE( 882)			h = this->_hx___stage->stageHeight;
            		}
            		else {
HXLINE( 882)			h = this->_hx___defaultRenderTarget->height;
            		}
HXLINE( 884)		int _hx_tmp;
HXDLIN( 884)		if (hx::IsNull( this->_hx___defaultRenderTarget )) {
HXLINE( 884)			 ::openfl::geom::Matrix _this = this->_hx___worldTransform;
HXDLIN( 884)			Float _hx_tmp1 = ((int)0 * _this->a);
HXDLIN( 884)			_hx_tmp = ::Math_obj::round(((_hx_tmp1 + ((int)0 * _this->c)) + _this->tx));
            		}
            		else {
HXLINE( 884)			_hx_tmp = (int)0;
            		}
HXDLIN( 884)		this->_hx___offsetX = _hx_tmp;
HXLINE( 885)		int _hx_tmp2;
HXDLIN( 885)		if (hx::IsNull( this->_hx___defaultRenderTarget )) {
HXLINE( 885)			 ::openfl::geom::Matrix _this1 = this->_hx___worldTransform;
HXDLIN( 885)			Float _hx_tmp3 = ((int)0 * _this1->b);
HXDLIN( 885)			_hx_tmp2 = ::Math_obj::round(((_hx_tmp3 + ((int)0 * _this1->d)) + _this1->ty));
            		}
            		else {
HXLINE( 885)			_hx_tmp2 = (int)0;
            		}
HXDLIN( 885)		this->_hx___offsetY = _hx_tmp2;
HXLINE( 886)		int _hx_tmp4;
HXDLIN( 886)		if (hx::IsNull( this->_hx___defaultRenderTarget )) {
HXLINE( 886)			 ::openfl::geom::Matrix _this2 = this->_hx___worldTransform;
HXDLIN( 886)			Float _hx_tmp5 = (w * _this2->a);
HXDLIN( 886)			_hx_tmp4 = ::Math_obj::round((((_hx_tmp5 + ((int)0 * _this2->c)) + _this2->tx) - this->_hx___offsetX));
            		}
            		else {
HXLINE( 886)			_hx_tmp4 = w;
            		}
HXDLIN( 886)		this->_hx___displayWidth = _hx_tmp4;
HXLINE( 887)		int _hx_tmp6;
HXDLIN( 887)		if (hx::IsNull( this->_hx___defaultRenderTarget )) {
HXLINE( 887)			 ::openfl::geom::Matrix _this3 = this->_hx___worldTransform;
HXDLIN( 887)			Float _hx_tmp7 = ((int)0 * _this3->b);
HXDLIN( 887)			_hx_tmp6 = ::Math_obj::round((((_hx_tmp7 + (h * _this3->d)) + _this3->ty) - this->_hx___offsetY));
            		}
            		else {
HXLINE( 887)			_hx_tmp6 = h;
            		}
HXDLIN( 887)		this->_hx___displayHeight = _hx_tmp6;
HXLINE( 890)		 ::lime::utils::ArrayBufferView _hx_tmp8 = this->_hx___projection;
HXDLIN( 890)		int _hx_tmp9 = this->_hx___offsetX;
HXDLIN( 890)		int _hx_tmp10 = (this->_hx___displayWidth + this->_hx___offsetX);
HXDLIN( 890)		int _hx_tmp11 = this->_hx___offsetY;
HXDLIN( 890)		::lime::math::_Matrix4::Matrix4_Impl__obj::createOrtho(_hx_tmp8,_hx_tmp9,_hx_tmp10,_hx_tmp11,(this->_hx___displayHeight + this->_hx___offsetY),(int)-1000,(int)1000);
HXLINE( 891)		 ::lime::utils::ArrayBufferView _hx_tmp12 = this->_hx___projectionFlipped;
HXDLIN( 891)		int _hx_tmp13 = this->_hx___offsetX;
HXDLIN( 891)		int _hx_tmp14 = (this->_hx___displayWidth + this->_hx___offsetX);
HXDLIN( 891)		::lime::math::_Matrix4::Matrix4_Impl__obj::createOrtho(_hx_tmp12,_hx_tmp13,_hx_tmp14,(this->_hx___displayHeight + this->_hx___offsetY),this->_hx___offsetY,(int)-1000,(int)1000);
            	}


void OpenGLRenderer_obj::_hx___resumeClipAndMask( ::openfl::display::OpenGLRenderer childRenderer){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_900___resumeClipAndMask)
HXLINE( 902)		if ((this->_hx___stencilReference > (int)0)) {
HXLINE( 904)			this->_hx___gl->enable(this->_hx___gl->STENCIL_TEST);
            		}
            		else {
HXLINE( 908)			this->_hx___gl->disable(this->_hx___gl->STENCIL_TEST);
            		}
HXLINE( 912)		if ((this->_hx___numClipRects > (int)0)) {
HXLINE( 914)			::Array< ::Dynamic> _hx_tmp = this->_hx___clipRects;
HXDLIN( 914)			this->_hx___scissorRect(_hx_tmp->__get((this->_hx___numClipRects - (int)1)).StaticCast<  ::openfl::geom::Rectangle >());
            		}
            		else {
HXLINE( 918)			this->_hx___scissorRect(null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,_hx___resumeClipAndMask,(void))

void OpenGLRenderer_obj::_hx___scissorRect( ::openfl::geom::Rectangle clipRect){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_927___scissorRect)
HXDLIN( 927)		if (hx::IsNotNull( clipRect )) {
HXLINE( 929)			this->_hx___gl->enable(this->_hx___gl->SCISSOR_TEST);
HXLINE( 931)			int x = ::Math_obj::floor(clipRect->x);
HXLINE( 932)			int y = ::Math_obj::floor(clipRect->y);
HXLINE( 933)			int width = (::Math_obj::ceil(clipRect->get_right()) - x);
HXLINE( 934)			int height = (::Math_obj::ceil(clipRect->get_bottom()) - y);
HXLINE( 936)			if ((width < (int)0)) {
HXLINE( 936)				width = (int)0;
            			}
HXLINE( 937)			if ((height < (int)0)) {
HXLINE( 937)				height = (int)0;
            			}
HXLINE( 939)			{
HXLINE( 939)				int y1;
HXDLIN( 939)				if (this->_hx___flipped) {
HXLINE( 939)					y1 = ((this->_hx___height - y) - height);
            				}
            				else {
HXLINE( 939)					y1 = y;
            				}
HXDLIN( 939)				this->_hx___gl->scissor(x,y1,width,height);
            			}
            		}
            		else {
HXLINE( 943)			this->_hx___gl->disable(this->_hx___gl->SCISSOR_TEST);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,_hx___scissorRect,(void))

void OpenGLRenderer_obj::_hx___setBlendMode( ::Dynamic value){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_950___setBlendMode)
HXLINE( 952)		if (hx::IsEq( this->_hx___blendMode,value )) {
HXLINE( 952)			return;
            		}
HXLINE( 954)		this->_hx___blendMode = value;
HXLINE( 956)		 ::Dynamic _hx_switch_0 = value;
            		if (  (_hx_switch_0==(int)0) ){
HXLINE( 960)			this->_hx___gl->blendEquation(this->_hx___gl->FUNC_ADD);
HXLINE( 961)			this->_hx___gl->blendFunc(this->_hx___gl->ONE,this->_hx___gl->ONE);
HXLINE( 958)			goto _hx_goto_36;
            		}
            		if (  (_hx_switch_0==(int)2) ){
HXLINE( 981)			this->_hx___gl->blendEquation((int)32775);
HXLINE( 982)			this->_hx___gl->blendFunc(this->_hx___gl->ONE,this->_hx___gl->ONE);
HXLINE( 979)			goto _hx_goto_36;
            		}
            		if (  (_hx_switch_0==(int)8) ){
HXLINE( 986)			this->_hx___gl->blendEquation((int)32776);
HXLINE( 987)			this->_hx___gl->blendFunc(this->_hx___gl->ONE,this->_hx___gl->ONE);
HXLINE( 984)			goto _hx_goto_36;
            		}
            		if (  (_hx_switch_0==(int)9) ){
HXLINE( 965)			this->_hx___gl->blendEquation(this->_hx___gl->FUNC_ADD);
HXLINE( 966)			this->_hx___gl->blendFunc(this->_hx___gl->DST_COLOR,this->_hx___gl->ONE_MINUS_SRC_ALPHA);
HXLINE( 963)			goto _hx_goto_36;
            		}
            		if (  (_hx_switch_0==(int)12) ){
HXLINE( 970)			this->_hx___gl->blendEquation(this->_hx___gl->FUNC_ADD);
HXLINE( 971)			this->_hx___gl->blendFunc(this->_hx___gl->ONE,this->_hx___gl->ONE_MINUS_SRC_COLOR);
HXLINE( 968)			goto _hx_goto_36;
            		}
            		if (  (_hx_switch_0==(int)14) ){
HXLINE( 975)			this->_hx___gl->blendEquation(this->_hx___gl->FUNC_REVERSE_SUBTRACT);
HXLINE( 976)			this->_hx___gl->blendFunc(this->_hx___gl->ONE,this->_hx___gl->ONE);
HXLINE( 973)			goto _hx_goto_36;
            		}
            		/* default */{
HXLINE( 992)			this->_hx___gl->blendEquation(this->_hx___gl->FUNC_ADD);
HXLINE( 993)			this->_hx___gl->blendFunc(this->_hx___gl->ONE,this->_hx___gl->ONE_MINUS_SRC_ALPHA);
            		}
            		_hx_goto_36:;
            	}


void OpenGLRenderer_obj::_hx___setRenderTarget( ::openfl::display::BitmapData renderTarget){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_1000___setRenderTarget)
HXLINE(1002)		this->_hx___defaultRenderTarget = renderTarget;
HXLINE(1003)		this->_hx___flipped = hx::IsNull( renderTarget );
HXLINE(1005)		if (hx::IsNotNull( renderTarget )) {
HXLINE(1007)			this->_hx___resize(renderTarget->width,renderTarget->height);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,_hx___setRenderTarget,(void))

void OpenGLRenderer_obj::_hx___setShaderBuffer( ::openfl::_internal::renderer::ShaderBuffer shaderBuffer){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_1014___setShaderBuffer)
HXLINE(1016)		this->setShader(shaderBuffer->shader);
HXLINE(1017)		this->_hx___currentShaderBuffer = shaderBuffer;
            	}


HX_DEFINE_DYNAMIC_FUNC1(OpenGLRenderer_obj,_hx___setShaderBuffer,(void))

void OpenGLRenderer_obj::_hx___suspendClipAndMask(){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_1022___suspendClipAndMask)
HXLINE(1024)		if ((this->_hx___stencilReference > (int)0)) {
HXLINE(1026)			this->_hx___gl->disable(this->_hx___gl->STENCIL_TEST);
            		}
HXLINE(1030)		if ((this->_hx___numClipRects > (int)0)) {
HXLINE(1032)			this->_hx___scissorRect(null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(OpenGLRenderer_obj,_hx___suspendClipAndMask,(void))

void OpenGLRenderer_obj::_hx___updateShaderBuffer(){
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_1041___updateShaderBuffer)
HXDLIN(1041)		bool _hx_tmp;
HXDLIN(1041)		if (hx::IsNotNull( this->_hx___currentShader )) {
HXDLIN(1041)			_hx_tmp = hx::IsNotNull( this->_hx___currentShaderBuffer );
            		}
            		else {
HXDLIN(1041)			_hx_tmp = false;
            		}
HXDLIN(1041)		if (_hx_tmp) {
HXLINE(1043)			this->_hx___currentShader->_hx___updateFromBuffer(this->_hx___currentShaderBuffer);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(OpenGLRenderer_obj,_hx___updateShaderBuffer,(void))

::Array< Float > OpenGLRenderer_obj::_hx___alphaValue;

::Array< Float > OpenGLRenderer_obj::_hx___colorMultipliersValue;

::Array< Float > OpenGLRenderer_obj::_hx___colorOffsetsValue;

::Array< Float > OpenGLRenderer_obj::_hx___defaultColorMultipliersValue;

::Array< Float > OpenGLRenderer_obj::_hx___emptyColorValue;

::Array< Float > OpenGLRenderer_obj::_hx___emptyAlphaValue;

::Array< bool > OpenGLRenderer_obj::_hx___hasColorTransformValue;

::Array< Float > OpenGLRenderer_obj::_hx___textureSizeValue;


hx::ObjectPtr< OpenGLRenderer_obj > OpenGLRenderer_obj::__new( ::lime::graphics::RenderContext context, ::openfl::display::BitmapData defaultRenderTarget) {
	hx::ObjectPtr< OpenGLRenderer_obj > __this = new OpenGLRenderer_obj();
	__this->__construct(context,defaultRenderTarget);
	return __this;
}

hx::ObjectPtr< OpenGLRenderer_obj > OpenGLRenderer_obj::__alloc(hx::Ctx *_hx_ctx, ::lime::graphics::RenderContext context, ::openfl::display::BitmapData defaultRenderTarget) {
	OpenGLRenderer_obj *__this = (OpenGLRenderer_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(OpenGLRenderer_obj), true, "openfl.display.OpenGLRenderer"));
	*(void **)__this = OpenGLRenderer_obj::_hx_vtable;
	__this->__construct(context,defaultRenderTarget);
	return __this;
}

OpenGLRenderer_obj::OpenGLRenderer_obj()
{
}

void OpenGLRenderer_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(OpenGLRenderer);
	HX_MARK_MEMBER_NAME(gl,"gl");
	HX_MARK_MEMBER_NAME(_hx___clipRects,"__clipRects");
	HX_MARK_MEMBER_NAME(_hx___currentDisplayShader,"__currentDisplayShader");
	HX_MARK_MEMBER_NAME(_hx___currentGraphicsShader,"__currentGraphicsShader");
	HX_MARK_MEMBER_NAME(_hx___currentRenderTarget,"__currentRenderTarget");
	HX_MARK_MEMBER_NAME(_hx___currentShader,"__currentShader");
	HX_MARK_MEMBER_NAME(_hx___currentShaderBuffer,"__currentShaderBuffer");
	HX_MARK_MEMBER_NAME(_hx___defaultDisplayShader,"__defaultDisplayShader");
	HX_MARK_MEMBER_NAME(_hx___defaultGraphicsShader,"__defaultGraphicsShader");
	HX_MARK_MEMBER_NAME(_hx___defaultRenderTarget,"__defaultRenderTarget");
	HX_MARK_MEMBER_NAME(_hx___defaultShader,"__defaultShader");
	HX_MARK_MEMBER_NAME(_hx___displayHeight,"__displayHeight");
	HX_MARK_MEMBER_NAME(_hx___displayWidth,"__displayWidth");
	HX_MARK_MEMBER_NAME(_hx___flipped,"__flipped");
	HX_MARK_MEMBER_NAME(_hx___gl,"__gl");
	HX_MARK_MEMBER_NAME(_hx___height,"__height");
	HX_MARK_MEMBER_NAME(_hx___maskShader,"__maskShader");
	HX_MARK_MEMBER_NAME(_hx___matrix,"__matrix");
	HX_MARK_MEMBER_NAME(_hx___maskObjects,"__maskObjects");
	HX_MARK_MEMBER_NAME(_hx___numClipRects,"__numClipRects");
	HX_MARK_MEMBER_NAME(_hx___offsetX,"__offsetX");
	HX_MARK_MEMBER_NAME(_hx___offsetY,"__offsetY");
	HX_MARK_MEMBER_NAME(_hx___projection,"__projection");
	HX_MARK_MEMBER_NAME(_hx___projectionFlipped,"__projectionFlipped");
	HX_MARK_MEMBER_NAME(_hx___softwareRenderer,"__softwareRenderer");
	HX_MARK_MEMBER_NAME(_hx___stencilReference,"__stencilReference");
	HX_MARK_MEMBER_NAME(_hx___tempRect,"__tempRect");
	HX_MARK_MEMBER_NAME(_hx___updatedStencil,"__updatedStencil");
	HX_MARK_MEMBER_NAME(_hx___upscaled,"__upscaled");
	HX_MARK_MEMBER_NAME(_hx___values,"__values");
	HX_MARK_MEMBER_NAME(_hx___width,"__width");
	 ::openfl::display::DisplayObjectRenderer_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void OpenGLRenderer_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(gl,"gl");
	HX_VISIT_MEMBER_NAME(_hx___clipRects,"__clipRects");
	HX_VISIT_MEMBER_NAME(_hx___currentDisplayShader,"__currentDisplayShader");
	HX_VISIT_MEMBER_NAME(_hx___currentGraphicsShader,"__currentGraphicsShader");
	HX_VISIT_MEMBER_NAME(_hx___currentRenderTarget,"__currentRenderTarget");
	HX_VISIT_MEMBER_NAME(_hx___currentShader,"__currentShader");
	HX_VISIT_MEMBER_NAME(_hx___currentShaderBuffer,"__currentShaderBuffer");
	HX_VISIT_MEMBER_NAME(_hx___defaultDisplayShader,"__defaultDisplayShader");
	HX_VISIT_MEMBER_NAME(_hx___defaultGraphicsShader,"__defaultGraphicsShader");
	HX_VISIT_MEMBER_NAME(_hx___defaultRenderTarget,"__defaultRenderTarget");
	HX_VISIT_MEMBER_NAME(_hx___defaultShader,"__defaultShader");
	HX_VISIT_MEMBER_NAME(_hx___displayHeight,"__displayHeight");
	HX_VISIT_MEMBER_NAME(_hx___displayWidth,"__displayWidth");
	HX_VISIT_MEMBER_NAME(_hx___flipped,"__flipped");
	HX_VISIT_MEMBER_NAME(_hx___gl,"__gl");
	HX_VISIT_MEMBER_NAME(_hx___height,"__height");
	HX_VISIT_MEMBER_NAME(_hx___maskShader,"__maskShader");
	HX_VISIT_MEMBER_NAME(_hx___matrix,"__matrix");
	HX_VISIT_MEMBER_NAME(_hx___maskObjects,"__maskObjects");
	HX_VISIT_MEMBER_NAME(_hx___numClipRects,"__numClipRects");
	HX_VISIT_MEMBER_NAME(_hx___offsetX,"__offsetX");
	HX_VISIT_MEMBER_NAME(_hx___offsetY,"__offsetY");
	HX_VISIT_MEMBER_NAME(_hx___projection,"__projection");
	HX_VISIT_MEMBER_NAME(_hx___projectionFlipped,"__projectionFlipped");
	HX_VISIT_MEMBER_NAME(_hx___softwareRenderer,"__softwareRenderer");
	HX_VISIT_MEMBER_NAME(_hx___stencilReference,"__stencilReference");
	HX_VISIT_MEMBER_NAME(_hx___tempRect,"__tempRect");
	HX_VISIT_MEMBER_NAME(_hx___updatedStencil,"__updatedStencil");
	HX_VISIT_MEMBER_NAME(_hx___upscaled,"__upscaled");
	HX_VISIT_MEMBER_NAME(_hx___values,"__values");
	HX_VISIT_MEMBER_NAME(_hx___width,"__width");
	 ::openfl::display::DisplayObjectRenderer_obj::__Visit(HX_VISIT_ARG);
}

hx::Val OpenGLRenderer_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { return hx::Val( gl ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"__gl") ) { return hx::Val( _hx___gl ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"__width") ) { return hx::Val( _hx___width ); }
		if (HX_FIELD_EQ(inName,"__clear") ) { return hx::Val( _hx___clear_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"__height") ) { return hx::Val( _hx___height ); }
		if (HX_FIELD_EQ(inName,"__matrix") ) { return hx::Val( _hx___matrix ); }
		if (HX_FIELD_EQ(inName,"__values") ) { return hx::Val( _hx___values ); }
		if (HX_FIELD_EQ(inName,"__render") ) { return hx::Val( _hx___render_dyn() ); }
		if (HX_FIELD_EQ(inName,"__resize") ) { return hx::Val( _hx___resize_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"__flipped") ) { return hx::Val( _hx___flipped ); }
		if (HX_FIELD_EQ(inName,"__offsetX") ) { return hx::Val( _hx___offsetX ); }
		if (HX_FIELD_EQ(inName,"__offsetY") ) { return hx::Val( _hx___offsetY ); }
		if (HX_FIELD_EQ(inName,"getMatrix") ) { return hx::Val( getMatrix_dyn() ); }
		if (HX_FIELD_EQ(inName,"setShader") ) { return hx::Val( setShader_dyn() ); }
		if (HX_FIELD_EQ(inName,"__cleanup") ) { return hx::Val( _hx___cleanup_dyn() ); }
		if (HX_FIELD_EQ(inName,"__popMask") ) { return hx::Val( _hx___popMask_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"__tempRect") ) { return hx::Val( _hx___tempRect ); }
		if (HX_FIELD_EQ(inName,"__upscaled") ) { return hx::Val( _hx___upscaled ); }
		if (HX_FIELD_EQ(inName,"applyAlpha") ) { return hx::Val( applyAlpha_dyn() ); }
		if (HX_FIELD_EQ(inName,"__pushMask") ) { return hx::Val( _hx___pushMask_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"__clipRects") ) { return hx::Val( _hx___clipRects ); }
		if (HX_FIELD_EQ(inName,"applyMatrix") ) { return hx::Val( applyMatrix_dyn() ); }
		if (HX_FIELD_EQ(inName,"setViewport") ) { return hx::Val( setViewport_dyn() ); }
		if (HX_FIELD_EQ(inName,"__getMatrix") ) { return hx::Val( _hx___getMatrix_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"__maskShader") ) { return hx::Val( _hx___maskShader ); }
		if (HX_FIELD_EQ(inName,"__projection") ) { return hx::Val( _hx___projection ); }
		if (HX_FIELD_EQ(inName,"updateShader") ) { return hx::Val( updateShader_dyn() ); }
		if (HX_FIELD_EQ(inName,"__copyShader") ) { return hx::Val( _hx___copyShader_dyn() ); }
		if (HX_FIELD_EQ(inName,"__initShader") ) { return hx::Val( _hx___initShader_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"__maskObjects") ) { return hx::Val( _hx___maskObjects ); }
		if (HX_FIELD_EQ(inName,"useAlphaArray") ) { return hx::Val( useAlphaArray_dyn() ); }
		if (HX_FIELD_EQ(inName,"__clearShader") ) { return hx::Val( _hx___clearShader_dyn() ); }
		if (HX_FIELD_EQ(inName,"__popMaskRect") ) { return hx::Val( _hx___popMaskRect_dyn() ); }
		if (HX_FIELD_EQ(inName,"__scissorRect") ) { return hx::Val( _hx___scissorRect_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"__displayWidth") ) { return hx::Val( _hx___displayWidth ); }
		if (HX_FIELD_EQ(inName,"__numClipRects") ) { return hx::Val( _hx___numClipRects ); }
		if (HX_FIELD_EQ(inName,"__pushMaskRect") ) { return hx::Val( _hx___pushMaskRect_dyn() ); }
		if (HX_FIELD_EQ(inName,"__setBlendMode") ) { return hx::Val( _hx___setBlendMode_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"__currentShader") ) { return hx::Val( _hx___currentShader ); }
		if (HX_FIELD_EQ(inName,"__defaultShader") ) { return hx::Val( _hx___defaultShader ); }
		if (HX_FIELD_EQ(inName,"__displayHeight") ) { return hx::Val( _hx___displayHeight ); }
		if (HX_FIELD_EQ(inName,"applyBitmapData") ) { return hx::Val( applyBitmapData_dyn() ); }
		if (HX_FIELD_EQ(inName,"__popMaskObject") ) { return hx::Val( _hx___popMaskObject_dyn() ); }
		if (HX_FIELD_EQ(inName,"__renderStage3D") ) { return hx::Val( _hx___renderStage3D_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"__updatedStencil") ) { return hx::Val( _hx___updatedStencil ); }
		if (HX_FIELD_EQ(inName,"__pushMaskObject") ) { return hx::Val( _hx___pushMaskObject_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"__setRenderTarget") ) { return hx::Val( _hx___setRenderTarget_dyn() ); }
		if (HX_FIELD_EQ(inName,"__setShaderBuffer") ) { return hx::Val( _hx___setShaderBuffer_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"__softwareRenderer") ) { return hx::Val( _hx___softwareRenderer ); }
		if (HX_FIELD_EQ(inName,"__stencilReference") ) { return hx::Val( _hx___stencilReference ); }
		if (HX_FIELD_EQ(inName,"__initShaderBuffer") ) { return hx::Val( _hx___initShaderBuffer_dyn() ); }
		if (HX_FIELD_EQ(inName,"__renderFilterPass") ) { return hx::Val( _hx___renderFilterPass_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"__projectionFlipped") ) { return hx::Val( _hx___projectionFlipped ); }
		if (HX_FIELD_EQ(inName,"applyColorTransform") ) { return hx::Val( applyColorTransform_dyn() ); }
		if (HX_FIELD_EQ(inName,"__initDisplayShader") ) { return hx::Val( _hx___initDisplayShader_dyn() ); }
		if (HX_FIELD_EQ(inName,"__resumeClipAndMask") ) { return hx::Val( _hx___resumeClipAndMask_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"__initGraphicsShader") ) { return hx::Val( _hx___initGraphicsShader_dyn() ); }
		if (HX_FIELD_EQ(inName,"__suspendClipAndMask") ) { return hx::Val( _hx___suspendClipAndMask_dyn() ); }
		if (HX_FIELD_EQ(inName,"__updateShaderBuffer") ) { return hx::Val( _hx___updateShaderBuffer_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"__currentRenderTarget") ) { return hx::Val( _hx___currentRenderTarget ); }
		if (HX_FIELD_EQ(inName,"__currentShaderBuffer") ) { return hx::Val( _hx___currentShaderBuffer ); }
		if (HX_FIELD_EQ(inName,"__defaultRenderTarget") ) { return hx::Val( _hx___defaultRenderTarget ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"__currentDisplayShader") ) { return hx::Val( _hx___currentDisplayShader ); }
		if (HX_FIELD_EQ(inName,"__defaultDisplayShader") ) { return hx::Val( _hx___defaultDisplayShader ); }
		if (HX_FIELD_EQ(inName,"applyHasColorTransform") ) { return hx::Val( applyHasColorTransform_dyn() ); }
		if (HX_FIELD_EQ(inName,"useColorTransformArray") ) { return hx::Val( useColorTransformArray_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"__currentGraphicsShader") ) { return hx::Val( _hx___currentGraphicsShader ); }
		if (HX_FIELD_EQ(inName,"__defaultGraphicsShader") ) { return hx::Val( _hx___defaultGraphicsShader ); }
	}
	return super::__Field(inName,inCallProp);
}

bool OpenGLRenderer_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"__alphaValue") ) { outValue = ( _hx___alphaValue ); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"__emptyColorValue") ) { outValue = ( _hx___emptyColorValue ); return true; }
		if (HX_FIELD_EQ(inName,"__emptyAlphaValue") ) { outValue = ( _hx___emptyAlphaValue ); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"__textureSizeValue") ) { outValue = ( _hx___textureSizeValue ); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"__colorOffsetsValue") ) { outValue = ( _hx___colorOffsetsValue ); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"__colorMultipliersValue") ) { outValue = ( _hx___colorMultipliersValue ); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"__hasColorTransformValue") ) { outValue = ( _hx___hasColorTransformValue ); return true; }
		break;
	case 30:
		if (HX_FIELD_EQ(inName,"__defaultColorMultipliersValue") ) { outValue = ( _hx___defaultColorMultipliersValue ); return true; }
	}
	return false;
}

hx::Val OpenGLRenderer_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"gl") ) { gl=inValue.Cast<  ::lime::_internal::backend::native::NativeOpenGLRenderContext >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"__gl") ) { _hx___gl=inValue.Cast<  ::lime::_internal::backend::native::NativeOpenGLRenderContext >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"__width") ) { _hx___width=inValue.Cast< int >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"__height") ) { _hx___height=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__matrix") ) { _hx___matrix=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__values") ) { _hx___values=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"__flipped") ) { _hx___flipped=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__offsetX") ) { _hx___offsetX=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__offsetY") ) { _hx___offsetY=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"__tempRect") ) { _hx___tempRect=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__upscaled") ) { _hx___upscaled=inValue.Cast< bool >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"__clipRects") ) { _hx___clipRects=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"__maskShader") ) { _hx___maskShader=inValue.Cast<  ::openfl::_internal::renderer::opengl::GLMaskShader >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__projection") ) { _hx___projection=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"__maskObjects") ) { _hx___maskObjects=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"__displayWidth") ) { _hx___displayWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__numClipRects") ) { _hx___numClipRects=inValue.Cast< int >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"__currentShader") ) { _hx___currentShader=inValue.Cast<  ::openfl::display::Shader >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__defaultShader") ) { _hx___defaultShader=inValue.Cast<  ::openfl::display::Shader >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__displayHeight") ) { _hx___displayHeight=inValue.Cast< int >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"__updatedStencil") ) { _hx___updatedStencil=inValue.Cast< bool >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"__softwareRenderer") ) { _hx___softwareRenderer=inValue.Cast<  ::openfl::display::DisplayObjectRenderer >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__stencilReference") ) { _hx___stencilReference=inValue.Cast< int >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"__projectionFlipped") ) { _hx___projectionFlipped=inValue.Cast<  ::lime::utils::ArrayBufferView >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"__currentRenderTarget") ) { _hx___currentRenderTarget=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__currentShaderBuffer") ) { _hx___currentShaderBuffer=inValue.Cast<  ::openfl::_internal::renderer::ShaderBuffer >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__defaultRenderTarget") ) { _hx___defaultRenderTarget=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"__currentDisplayShader") ) { _hx___currentDisplayShader=inValue.Cast<  ::openfl::display::Shader >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__defaultDisplayShader") ) { _hx___defaultDisplayShader=inValue.Cast<  ::openfl::display::DisplayObjectShader >(); return inValue; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"__currentGraphicsShader") ) { _hx___currentGraphicsShader=inValue.Cast<  ::openfl::display::Shader >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__defaultGraphicsShader") ) { _hx___defaultGraphicsShader=inValue.Cast<  ::openfl::display::GraphicsShader >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool OpenGLRenderer_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"__alphaValue") ) { _hx___alphaValue=ioValue.Cast< ::Array< Float > >(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"__emptyColorValue") ) { _hx___emptyColorValue=ioValue.Cast< ::Array< Float > >(); return true; }
		if (HX_FIELD_EQ(inName,"__emptyAlphaValue") ) { _hx___emptyAlphaValue=ioValue.Cast< ::Array< Float > >(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"__textureSizeValue") ) { _hx___textureSizeValue=ioValue.Cast< ::Array< Float > >(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"__colorOffsetsValue") ) { _hx___colorOffsetsValue=ioValue.Cast< ::Array< Float > >(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"__colorMultipliersValue") ) { _hx___colorMultipliersValue=ioValue.Cast< ::Array< Float > >(); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"__hasColorTransformValue") ) { _hx___hasColorTransformValue=ioValue.Cast< ::Array< bool > >(); return true; }
		break;
	case 30:
		if (HX_FIELD_EQ(inName,"__defaultColorMultipliersValue") ) { _hx___defaultColorMultipliersValue=ioValue.Cast< ::Array< Float > >(); return true; }
	}
	return false;
}

void OpenGLRenderer_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("gl","\x25","\x5a","\x00","\x00"));
	outFields->push(HX_HCSTRING("__clipRects","\xbf","\xca","\xff","\x32"));
	outFields->push(HX_HCSTRING("__currentDisplayShader","\x2e","\xe2","\xbe","\x27"));
	outFields->push(HX_HCSTRING("__currentGraphicsShader","\x49","\x31","\xab","\x3a"));
	outFields->push(HX_HCSTRING("__currentRenderTarget","\x00","\xf2","\x02","\x95"));
	outFields->push(HX_HCSTRING("__currentShader","\x1e","\x79","\x2f","\x88"));
	outFields->push(HX_HCSTRING("__currentShaderBuffer","\xbe","\x54","\x3d","\xdf"));
	outFields->push(HX_HCSTRING("__defaultDisplayShader","\xa6","\x70","\x7d","\xf7"));
	outFields->push(HX_HCSTRING("__defaultGraphicsShader","\xd1","\x4b","\xa9","\x31"));
	outFields->push(HX_HCSTRING("__defaultRenderTarget","\x88","\xda","\x8f","\xe0"));
	outFields->push(HX_HCSTRING("__defaultShader","\xa6","\xcb","\x4b","\x9f"));
	outFields->push(HX_HCSTRING("__displayHeight","\xa9","\xfc","\x60","\x4b"));
	outFields->push(HX_HCSTRING("__displayWidth","\x84","\x0f","\x7c","\xf7"));
	outFields->push(HX_HCSTRING("__flipped","\x22","\xbd","\xd6","\x00"));
	outFields->push(HX_HCSTRING("__gl","\x45","\xb5","\x13","\x3f"));
	outFields->push(HX_HCSTRING("__height","\x07","\x73","\x7b","\xaa"));
	outFields->push(HX_HCSTRING("__maskShader","\x51","\x68","\x98","\x6a"));
	outFields->push(HX_HCSTRING("__matrix","\x61","\xa1","\xf7","\x63"));
	outFields->push(HX_HCSTRING("__maskObjects","\x28","\xc6","\x8b","\xfd"));
	outFields->push(HX_HCSTRING("__numClipRects","\xd9","\x0d","\x04","\xcd"));
	outFields->push(HX_HCSTRING("__offsetX","\x45","\x5a","\xb3","\x58"));
	outFields->push(HX_HCSTRING("__offsetY","\x46","\x5a","\xb3","\x58"));
	outFields->push(HX_HCSTRING("__projection","\xaf","\x03","\x1f","\xfd"));
	outFields->push(HX_HCSTRING("__projectionFlipped","\x53","\xf4","\x6c","\x72"));
	outFields->push(HX_HCSTRING("__softwareRenderer","\xaa","\x4f","\xcd","\x76"));
	outFields->push(HX_HCSTRING("__stencilReference","\x4f","\x1d","\x93","\x93"));
	outFields->push(HX_HCSTRING("__tempRect","\x78","\xc9","\x53","\x3e"));
	outFields->push(HX_HCSTRING("__updatedStencil","\x21","\x3c","\xc1","\x34"));
	outFields->push(HX_HCSTRING("__upscaled","\x55","\x7a","\xd0","\x34"));
	outFields->push(HX_HCSTRING("__values","\x02","\x6f","\xe6","\xf7"));
	outFields->push(HX_HCSTRING("__width","\xe6","\x0e","\xc1","\x34"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo OpenGLRenderer_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::lime::_internal::backend::native::NativeOpenGLRenderContext*/ ,(int)offsetof(OpenGLRenderer_obj,gl),HX_HCSTRING("gl","\x25","\x5a","\x00","\x00")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___clipRects),HX_HCSTRING("__clipRects","\xbf","\xca","\xff","\x32")},
	{hx::fsObject /*::openfl::display::Shader*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___currentDisplayShader),HX_HCSTRING("__currentDisplayShader","\x2e","\xe2","\xbe","\x27")},
	{hx::fsObject /*::openfl::display::Shader*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___currentGraphicsShader),HX_HCSTRING("__currentGraphicsShader","\x49","\x31","\xab","\x3a")},
	{hx::fsObject /*::openfl::display::BitmapData*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___currentRenderTarget),HX_HCSTRING("__currentRenderTarget","\x00","\xf2","\x02","\x95")},
	{hx::fsObject /*::openfl::display::Shader*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___currentShader),HX_HCSTRING("__currentShader","\x1e","\x79","\x2f","\x88")},
	{hx::fsObject /*::openfl::_internal::renderer::ShaderBuffer*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___currentShaderBuffer),HX_HCSTRING("__currentShaderBuffer","\xbe","\x54","\x3d","\xdf")},
	{hx::fsObject /*::openfl::display::DisplayObjectShader*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___defaultDisplayShader),HX_HCSTRING("__defaultDisplayShader","\xa6","\x70","\x7d","\xf7")},
	{hx::fsObject /*::openfl::display::GraphicsShader*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___defaultGraphicsShader),HX_HCSTRING("__defaultGraphicsShader","\xd1","\x4b","\xa9","\x31")},
	{hx::fsObject /*::openfl::display::BitmapData*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___defaultRenderTarget),HX_HCSTRING("__defaultRenderTarget","\x88","\xda","\x8f","\xe0")},
	{hx::fsObject /*::openfl::display::Shader*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___defaultShader),HX_HCSTRING("__defaultShader","\xa6","\xcb","\x4b","\x9f")},
	{hx::fsInt,(int)offsetof(OpenGLRenderer_obj,_hx___displayHeight),HX_HCSTRING("__displayHeight","\xa9","\xfc","\x60","\x4b")},
	{hx::fsInt,(int)offsetof(OpenGLRenderer_obj,_hx___displayWidth),HX_HCSTRING("__displayWidth","\x84","\x0f","\x7c","\xf7")},
	{hx::fsBool,(int)offsetof(OpenGLRenderer_obj,_hx___flipped),HX_HCSTRING("__flipped","\x22","\xbd","\xd6","\x00")},
	{hx::fsObject /*::lime::_internal::backend::native::NativeOpenGLRenderContext*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___gl),HX_HCSTRING("__gl","\x45","\xb5","\x13","\x3f")},
	{hx::fsInt,(int)offsetof(OpenGLRenderer_obj,_hx___height),HX_HCSTRING("__height","\x07","\x73","\x7b","\xaa")},
	{hx::fsObject /*::openfl::_internal::renderer::opengl::GLMaskShader*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___maskShader),HX_HCSTRING("__maskShader","\x51","\x68","\x98","\x6a")},
	{hx::fsObject /*::lime::utils::ArrayBufferView*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___matrix),HX_HCSTRING("__matrix","\x61","\xa1","\xf7","\x63")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___maskObjects),HX_HCSTRING("__maskObjects","\x28","\xc6","\x8b","\xfd")},
	{hx::fsInt,(int)offsetof(OpenGLRenderer_obj,_hx___numClipRects),HX_HCSTRING("__numClipRects","\xd9","\x0d","\x04","\xcd")},
	{hx::fsInt,(int)offsetof(OpenGLRenderer_obj,_hx___offsetX),HX_HCSTRING("__offsetX","\x45","\x5a","\xb3","\x58")},
	{hx::fsInt,(int)offsetof(OpenGLRenderer_obj,_hx___offsetY),HX_HCSTRING("__offsetY","\x46","\x5a","\xb3","\x58")},
	{hx::fsObject /*::lime::utils::ArrayBufferView*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___projection),HX_HCSTRING("__projection","\xaf","\x03","\x1f","\xfd")},
	{hx::fsObject /*::lime::utils::ArrayBufferView*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___projectionFlipped),HX_HCSTRING("__projectionFlipped","\x53","\xf4","\x6c","\x72")},
	{hx::fsObject /*::openfl::display::DisplayObjectRenderer*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___softwareRenderer),HX_HCSTRING("__softwareRenderer","\xaa","\x4f","\xcd","\x76")},
	{hx::fsInt,(int)offsetof(OpenGLRenderer_obj,_hx___stencilReference),HX_HCSTRING("__stencilReference","\x4f","\x1d","\x93","\x93")},
	{hx::fsObject /*::openfl::geom::Rectangle*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___tempRect),HX_HCSTRING("__tempRect","\x78","\xc9","\x53","\x3e")},
	{hx::fsBool,(int)offsetof(OpenGLRenderer_obj,_hx___updatedStencil),HX_HCSTRING("__updatedStencil","\x21","\x3c","\xc1","\x34")},
	{hx::fsBool,(int)offsetof(OpenGLRenderer_obj,_hx___upscaled),HX_HCSTRING("__upscaled","\x55","\x7a","\xd0","\x34")},
	{hx::fsObject /*Array< Float >*/ ,(int)offsetof(OpenGLRenderer_obj,_hx___values),HX_HCSTRING("__values","\x02","\x6f","\xe6","\xf7")},
	{hx::fsInt,(int)offsetof(OpenGLRenderer_obj,_hx___width),HX_HCSTRING("__width","\xe6","\x0e","\xc1","\x34")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo OpenGLRenderer_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*Array< Float >*/ ,(void *) &OpenGLRenderer_obj::_hx___alphaValue,HX_HCSTRING("__alphaValue","\x53","\x4e","\xf1","\x8a")},
	{hx::fsObject /*Array< Float >*/ ,(void *) &OpenGLRenderer_obj::_hx___colorMultipliersValue,HX_HCSTRING("__colorMultipliersValue","\xa2","\x08","\xbb","\x81")},
	{hx::fsObject /*Array< Float >*/ ,(void *) &OpenGLRenderer_obj::_hx___colorOffsetsValue,HX_HCSTRING("__colorOffsetsValue","\xb4","\x64","\x83","\x33")},
	{hx::fsObject /*Array< Float >*/ ,(void *) &OpenGLRenderer_obj::_hx___defaultColorMultipliersValue,HX_HCSTRING("__defaultColorMultipliersValue","\x61","\x1c","\x3c","\xdd")},
	{hx::fsObject /*Array< Float >*/ ,(void *) &OpenGLRenderer_obj::_hx___emptyColorValue,HX_HCSTRING("__emptyColorValue","\xdb","\x98","\x57","\xb3")},
	{hx::fsObject /*Array< Float >*/ ,(void *) &OpenGLRenderer_obj::_hx___emptyAlphaValue,HX_HCSTRING("__emptyAlphaValue","\x00","\xd5","\x90","\xaf")},
	{hx::fsObject /*Array< bool >*/ ,(void *) &OpenGLRenderer_obj::_hx___hasColorTransformValue,HX_HCSTRING("__hasColorTransformValue","\x0e","\x4b","\x82","\xa1")},
	{hx::fsObject /*Array< Float >*/ ,(void *) &OpenGLRenderer_obj::_hx___textureSizeValue,HX_HCSTRING("__textureSizeValue","\xb5","\x29","\x2d","\x70")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String OpenGLRenderer_obj_sMemberFields[] = {
	HX_HCSTRING("gl","\x25","\x5a","\x00","\x00"),
	HX_HCSTRING("__clipRects","\xbf","\xca","\xff","\x32"),
	HX_HCSTRING("__currentDisplayShader","\x2e","\xe2","\xbe","\x27"),
	HX_HCSTRING("__currentGraphicsShader","\x49","\x31","\xab","\x3a"),
	HX_HCSTRING("__currentRenderTarget","\x00","\xf2","\x02","\x95"),
	HX_HCSTRING("__currentShader","\x1e","\x79","\x2f","\x88"),
	HX_HCSTRING("__currentShaderBuffer","\xbe","\x54","\x3d","\xdf"),
	HX_HCSTRING("__defaultDisplayShader","\xa6","\x70","\x7d","\xf7"),
	HX_HCSTRING("__defaultGraphicsShader","\xd1","\x4b","\xa9","\x31"),
	HX_HCSTRING("__defaultRenderTarget","\x88","\xda","\x8f","\xe0"),
	HX_HCSTRING("__defaultShader","\xa6","\xcb","\x4b","\x9f"),
	HX_HCSTRING("__displayHeight","\xa9","\xfc","\x60","\x4b"),
	HX_HCSTRING("__displayWidth","\x84","\x0f","\x7c","\xf7"),
	HX_HCSTRING("__flipped","\x22","\xbd","\xd6","\x00"),
	HX_HCSTRING("__gl","\x45","\xb5","\x13","\x3f"),
	HX_HCSTRING("__height","\x07","\x73","\x7b","\xaa"),
	HX_HCSTRING("__maskShader","\x51","\x68","\x98","\x6a"),
	HX_HCSTRING("__matrix","\x61","\xa1","\xf7","\x63"),
	HX_HCSTRING("__maskObjects","\x28","\xc6","\x8b","\xfd"),
	HX_HCSTRING("__numClipRects","\xd9","\x0d","\x04","\xcd"),
	HX_HCSTRING("__offsetX","\x45","\x5a","\xb3","\x58"),
	HX_HCSTRING("__offsetY","\x46","\x5a","\xb3","\x58"),
	HX_HCSTRING("__projection","\xaf","\x03","\x1f","\xfd"),
	HX_HCSTRING("__projectionFlipped","\x53","\xf4","\x6c","\x72"),
	HX_HCSTRING("__softwareRenderer","\xaa","\x4f","\xcd","\x76"),
	HX_HCSTRING("__stencilReference","\x4f","\x1d","\x93","\x93"),
	HX_HCSTRING("__tempRect","\x78","\xc9","\x53","\x3e"),
	HX_HCSTRING("__updatedStencil","\x21","\x3c","\xc1","\x34"),
	HX_HCSTRING("__upscaled","\x55","\x7a","\xd0","\x34"),
	HX_HCSTRING("__values","\x02","\x6f","\xe6","\xf7"),
	HX_HCSTRING("__width","\xe6","\x0e","\xc1","\x34"),
	HX_HCSTRING("applyAlpha","\x10","\x23","\xe8","\xcc"),
	HX_HCSTRING("applyBitmapData","\xc7","\x94","\xb7","\xf3"),
	HX_HCSTRING("applyColorTransform","\x97","\x55","\x2e","\x0b"),
	HX_HCSTRING("applyHasColorTransform","\x35","\x53","\xe0","\xcd"),
	HX_HCSTRING("applyMatrix","\x4f","\xf6","\xc2","\xf7"),
	HX_HCSTRING("getMatrix","\x77","\xbf","\x1e","\x38"),
	HX_HCSTRING("setShader","\x67","\x34","\xc8","\x7c"),
	HX_HCSTRING("setViewport","\x28","\x16","\x06","\xcd"),
	HX_HCSTRING("updateShader","\x0e","\x66","\xe4","\x1c"),
	HX_HCSTRING("useAlphaArray","\x82","\xb0","\x9d","\x7e"),
	HX_HCSTRING("useColorTransformArray","\x49","\x89","\x6f","\x74"),
	HX_HCSTRING("__cleanup","\x04","\x5d","\x90","\x2c"),
	HX_HCSTRING("__clear","\x6d","\xca","\xb9","\xb2"),
	HX_HCSTRING("__clearShader","\x72","\x0d","\x86","\xf9"),
	HX_HCSTRING("__copyShader","\xda","\x9f","\x78","\x0b"),
	HX_HCSTRING("__getMatrix","\x57","\x08","\x4b","\x66"),
	HX_HCSTRING("__initShader","\x75","\x95","\xf9","\x59"),
	HX_HCSTRING("__initDisplayShader","\xb7","\x0e","\xd5","\x77"),
	HX_HCSTRING("__initGraphicsShader","\xa0","\xfc","\xfb","\xfd"),
	HX_HCSTRING("__initShaderBuffer","\x55","\xcc","\x4f","\x9f"),
	HX_HCSTRING("__popMask","\xfd","\xb7","\x5f","\xc4"),
	HX_HCSTRING("__popMaskObject","\x9c","\x46","\x0d","\x10"),
	HX_HCSTRING("__popMaskRect","\xc1","\x73","\xe8","\x16"),
	HX_HCSTRING("__pushMask","\x06","\xe7","\x7f","\xba"),
	HX_HCSTRING("__pushMaskObject","\x65","\xe2","\x3b","\x45"),
	HX_HCSTRING("__pushMaskRect","\x4a","\x5b","\xe7","\xa0"),
	HX_HCSTRING("__render","\x76","\xd6","\x58","\xad"),
	HX_HCSTRING("__renderFilterPass","\xbf","\x36","\xcd","\x6c"),
	HX_HCSTRING("__renderStage3D","\x19","\xef","\x69","\xb1"),
	HX_HCSTRING("__resize","\x14","\xc5","\xaa","\xb0"),
	HX_HCSTRING("__resumeClipAndMask","\xa6","\x5e","\x6c","\xd9"),
	HX_HCSTRING("__scissorRect","\x40","\x20","\xcc","\xa9"),
	HX_HCSTRING("__setBlendMode","\x72","\x27","\x48","\x51"),
	HX_HCSTRING("__setRenderTarget","\xe9","\xfa","\x52","\x98"),
	HX_HCSTRING("__setShaderBuffer","\xa7","\x5d","\x8d","\xe2"),
	HX_HCSTRING("__suspendClipAndMask","\x77","\xcf","\x4a","\xd0"),
	HX_HCSTRING("__updateShaderBuffer","\xce","\x30","\xbe","\x97"),
	::String(null()) };

static void OpenGLRenderer_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(OpenGLRenderer_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(OpenGLRenderer_obj::_hx___alphaValue,"__alphaValue");
	HX_MARK_MEMBER_NAME(OpenGLRenderer_obj::_hx___colorMultipliersValue,"__colorMultipliersValue");
	HX_MARK_MEMBER_NAME(OpenGLRenderer_obj::_hx___colorOffsetsValue,"__colorOffsetsValue");
	HX_MARK_MEMBER_NAME(OpenGLRenderer_obj::_hx___defaultColorMultipliersValue,"__defaultColorMultipliersValue");
	HX_MARK_MEMBER_NAME(OpenGLRenderer_obj::_hx___emptyColorValue,"__emptyColorValue");
	HX_MARK_MEMBER_NAME(OpenGLRenderer_obj::_hx___emptyAlphaValue,"__emptyAlphaValue");
	HX_MARK_MEMBER_NAME(OpenGLRenderer_obj::_hx___hasColorTransformValue,"__hasColorTransformValue");
	HX_MARK_MEMBER_NAME(OpenGLRenderer_obj::_hx___textureSizeValue,"__textureSizeValue");
};

#ifdef HXCPP_VISIT_ALLOCS
static void OpenGLRenderer_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(OpenGLRenderer_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(OpenGLRenderer_obj::_hx___alphaValue,"__alphaValue");
	HX_VISIT_MEMBER_NAME(OpenGLRenderer_obj::_hx___colorMultipliersValue,"__colorMultipliersValue");
	HX_VISIT_MEMBER_NAME(OpenGLRenderer_obj::_hx___colorOffsetsValue,"__colorOffsetsValue");
	HX_VISIT_MEMBER_NAME(OpenGLRenderer_obj::_hx___defaultColorMultipliersValue,"__defaultColorMultipliersValue");
	HX_VISIT_MEMBER_NAME(OpenGLRenderer_obj::_hx___emptyColorValue,"__emptyColorValue");
	HX_VISIT_MEMBER_NAME(OpenGLRenderer_obj::_hx___emptyAlphaValue,"__emptyAlphaValue");
	HX_VISIT_MEMBER_NAME(OpenGLRenderer_obj::_hx___hasColorTransformValue,"__hasColorTransformValue");
	HX_VISIT_MEMBER_NAME(OpenGLRenderer_obj::_hx___textureSizeValue,"__textureSizeValue");
};

#endif

hx::Class OpenGLRenderer_obj::__mClass;

static ::String OpenGLRenderer_obj_sStaticFields[] = {
	HX_HCSTRING("__alphaValue","\x53","\x4e","\xf1","\x8a"),
	HX_HCSTRING("__colorMultipliersValue","\xa2","\x08","\xbb","\x81"),
	HX_HCSTRING("__colorOffsetsValue","\xb4","\x64","\x83","\x33"),
	HX_HCSTRING("__defaultColorMultipliersValue","\x61","\x1c","\x3c","\xdd"),
	HX_HCSTRING("__emptyColorValue","\xdb","\x98","\x57","\xb3"),
	HX_HCSTRING("__emptyAlphaValue","\x00","\xd5","\x90","\xaf"),
	HX_HCSTRING("__hasColorTransformValue","\x0e","\x4b","\x82","\xa1"),
	HX_HCSTRING("__textureSizeValue","\xb5","\x29","\x2d","\x70"),
	::String(null())
};

void OpenGLRenderer_obj::__register()
{
	hx::Object *dummy = new OpenGLRenderer_obj;
	OpenGLRenderer_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl.display.OpenGLRenderer","\xbc","\x6a","\xf8","\xfd");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &OpenGLRenderer_obj::__GetStatic;
	__mClass->mSetStaticField = &OpenGLRenderer_obj::__SetStatic;
	__mClass->mMarkFunc = OpenGLRenderer_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(OpenGLRenderer_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(OpenGLRenderer_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< OpenGLRenderer_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = OpenGLRenderer_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = OpenGLRenderer_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = OpenGLRenderer_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void OpenGLRenderer_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_57_boot)
HXDLIN(  57)		_hx___alphaValue = ::Array_obj< Float >::fromData( _hx_array_data_fdf86abc_43,1);
            	}
{
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_58_boot)
HXDLIN(  58)		_hx___colorMultipliersValue = ::Array_obj< Float >::fromData( _hx_array_data_fdf86abc_45,4);
            	}
{
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_59_boot)
HXDLIN(  59)		_hx___colorOffsetsValue = ::Array_obj< Float >::fromData( _hx_array_data_fdf86abc_47,4);
            	}
{
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_60_boot)
HXDLIN(  60)		_hx___defaultColorMultipliersValue = ::Array_obj< Float >::fromData( _hx_array_data_fdf86abc_49,4);
            	}
{
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_61_boot)
HXDLIN(  61)		_hx___emptyColorValue = ::Array_obj< Float >::fromData( _hx_array_data_fdf86abc_51,4);
            	}
{
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_62_boot)
HXDLIN(  62)		_hx___emptyAlphaValue = ::Array_obj< Float >::fromData( _hx_array_data_fdf86abc_53,1);
            	}
{
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_63_boot)
HXDLIN(  63)		_hx___hasColorTransformValue = ::Array_obj< bool >::fromData( _hx_array_data_fdf86abc_55,1);
            	}
{
            	HX_STACKFRAME(&_hx_pos_2f59d7e567bca573_64_boot)
HXDLIN(  64)		_hx___textureSizeValue = ::Array_obj< Float >::fromData( _hx_array_data_fdf86abc_57,2);
            	}
}

} // end namespace openfl
} // end namespace display
